{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QCManyBody Documentation","text":"<p>QCManyBody is a python package for running quantum chemistry manybody expansions and interaction calculations in a package-independent way.</p>"},{"location":"#installation","title":"Installation","text":"<p>Currently, the package is only available on GitHub. To install directly from GitHub, use the following command:</p> <pre><code>pip install git+https://github.com/MolSSI/QCManyBody.git\n</code></pre>"},{"location":"#package-overview","title":"Package Overview","text":"<p>The package has two main interfaces. The high-level interface allows for a comprehensive workflow, where the user provides complete information about the calculation, including the full specification (method, basis set, etc.) of the manybody calculation. This is designed to work with QCEngine or other packages that implement the QCSchema.</p> <p>For more information, see (High-level interface)(high-level-interface.md).</p> <p>QCManyBody also has a core low-level interface that allows for more flexibility in how the calculations are run. This interface generally takes a molecule and an arbitrary definition of quantum chemistry specifications, and expects the user to run them themselves.</p> <p>For more information, see (Core interface)(core-interface.md).</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Common Keywords and Options</li> <li>High-level Interface</li> <li>Core Interface</li> <li>Results</li> <li>How-To Guides</li> </ol>"},{"location":"api/","title":"API Documentation","text":"Source code in <code>qcmanybody/manybody.py</code> <pre><code>class ManyBodyCalculator:\n    def __init__(\n        self,\n        molecule: Molecule,\n        bsse_type: Sequence[BsseEnum],\n        levels: Mapping[Union[int, Literal[\"supersystem\"]], str],\n        return_total_data: bool,\n        supersystem_ie_only: bool,\n    ):\n        # TODO\n        self.embedding_charges = {}\n\n        self.molecule = molecule\n        self.bsse_type = [BsseEnum(x) for x in bsse_type]\n        self.return_total_data = return_total_data\n        self.supersystem_ie_only = supersystem_ie_only\n        self.nfragments = len(molecule.fragments)\n\n        self.levels = levels\n\n        # Levels without supersystem\n        self.levels_no_ss = {int(k): v for k, v in levels.items() if k != \"supersystem\"}\n\n        # Just a set of all the modelchems\n        self.mc_levels = set(self.levels.values())\n\n        self.max_nbody = max(self.levels_no_ss.keys())\n\n        if len(self.bsse_type) == 0:\n            raise ValueError(\"No BSSE correction specified\")\n\n        if BsseEnum.vmfc in self.bsse_type and len(set(self.levels.values())) == 1:\n            # For single-modelchem VMFC, NOCP &amp; sometimes CP are produced for free\n            if BsseEnum.nocp not in self.bsse_type:\n                self.bsse_type.append(BsseEnum.nocp)\n            if BsseEnum.cp not in self.bsse_type and self.max_nbody == self.nfragments:\n                self.bsse_type.append(BsseEnum.cp)\n\n        self.return_bsse_type = self.bsse_type[0]\n\n        ###############################\n        # Build nbodies_per_mc_level\n        # TODO - use Lori's code\n        # TODO - dict to list of lists to handle non-contiguous levels\n        # TODO multilevel and supersystem_ie_only=T not allowed together\n        # TODO supersystem in levels is not to be trusted -- nfrag only and skips levels\n        max_level = max(self.levels_no_ss.keys())\n\n        if set(range(1, max_level + 1)) != set(self.levels_no_ss.keys()):\n            raise ValueError(f\"Levels must be contiguous from 1 to {max_level}\")\n\n        self.nbodies_per_mc_level: Dict[str, list] = {mc_level: [] for mc_level in self.mc_levels}\n        for k, v in self.levels_no_ss.items():\n            self.nbodies_per_mc_level[v].append(k)\n\n        self.nbodies_per_mc_level = {k: sorted(v) for k, v in self.nbodies_per_mc_level.items()}\n\n        # Supersystem is always at the end\n        if \"supersystem\" in levels:\n            ss_mc = levels[\"supersystem\"]\n            self.nbodies_per_mc_level[ss_mc].append(\"supersystem\")\n\n        # To be built on the fly\n        self.mc_compute_dict = None\n\n        if not np.array_equal(np.concatenate(self.molecule.fragments), np.arange(len(self.molecule.symbols))):\n            raise ValueError(\"\"\"QCManyBody: non-contiguous fragments could be implemented but aren't at present\"\"\")\n\n        # Build size and slices dictionaries. Assumes fragments are contiguous\n        self.fragment_size_dict = {}\n        self.fragment_slice_dict = {}\n        iat = 0\n        for ifr in range(1, self.nfragments + 1):\n            nat = len(self.molecule.fragments[ifr - 1])\n            self.fragment_size_dict[ifr] = nat\n            self.fragment_slice_dict[ifr] = slice(iat, iat + nat)\n            iat += nat\n\n    @property\n    def has_supersystem(self) -&gt; bool:\n        return \"supersystem\" in self.levels\n\n    @property\n    def compute_map(self) -&gt; Dict[str, Dict[str, Dict[int, Set[FragBasIndex]]]]:\n        if self.mc_compute_dict is not None:\n            return self.mc_compute_dict\n\n        # Build the compute lists\n        self.mc_compute_dict = {}\n\n        for mc in self.mc_levels:\n            nbodies = self.nbodies_per_mc_level[mc]\n            self.mc_compute_dict[mc] = build_nbody_compute_list(\n                self.bsse_type,\n                self.nfragments,\n                nbodies,\n                self.return_total_data,\n                self.supersystem_ie_only,\n                self.max_nbody,\n            )\n\n        return self.mc_compute_dict\n\n    def format_calc_plan(self, sset: str = \"all\") -&gt; Tuple[str, Dict[str, Dict[int, int]]]:\n        \"\"\"Formulate per-modelchem and per-body job count data and summary text.\n\n        Parameters\n        ----------\n        sset\n            Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.\n\n        Returns\n        -------\n        info\n            A text summary with per- model chemistry and per- n-body-level job counts.\n        Dict[str, Dict[int, int]]\n            Data structure with outer key mc-label, inner key 1-indexed n-body, value job count.\n        \"\"\"\n        # Rearrange compute_list from key nb having values (species) to compute all of that nb\n        #   to key nb having values counting that nb.\n        compute_list_count = {}\n        for mc, compute_dict in self.compute_map.items():\n            compute_list_count[mc] = {}\n            for sub in compute_dict:  # all, nocp, cp, vmfc\n                all_calcs = set().union(*compute_dict[sub].values())\n                compute_list_count[mc][sub] = Counter([len(frag) for (frag, _) in all_calcs])\n\n        info = []\n        for mc, counter in compute_list_count.items():\n            all_counter = counter[\"all\"]\n            info.append(f\"    Model chemistry \\\"{mc}\\\" (???):    {sum(all_counter.values())}\")\n            for nb, count in sorted(all_counter.items()):\n                other_counts = [f\"{sub}: {counter[sub][nb]}\" for sub in [\"nocp\", \"cp\", \"vmfc_compute\"]]\n                info.append(f\"        Number of {nb}-body computations: {count:6} ({', '.join(other_counts)})\")\n            info.append(\"\")\n        info = \"\\n\".join(info)\n\n        logger.info(info)\n        return info, {mc: dsset[sset] for mc, dsset in compute_list_count.items()}\n\n    def resize_gradient(self, grad: np.ndarray, bas: Tuple[int, ...], *, reverse: bool = False) -&gt; np.ndarray:\n        return resize_gradient(grad, bas, self.fragment_size_dict, self.fragment_slice_dict, reverse=reverse)\n\n    def resize_hessian(self, hess: np.ndarray, bas: Tuple[int, ...], *, reverse: bool = False) -&gt; np.ndarray:\n        return resize_hessian(hess, bas, self.fragment_size_dict, self.fragment_slice_dict, reverse=reverse)\n\n    def iterate_molecules(self) -&gt; Iterable[Tuple[str, str, Molecule]]:\n        \"\"\"Iterate over all the molecules needed for the computation.\n\n        Yields model chemistry, label, and molecule.\n        \"\"\"\n\n        done_molecules = set()\n\n        for mc, compute_dict in self.compute_map.items():\n            # TODO - this is a bit of a hack. Lots of duplication when reaching higher nbody\n            for compute_list in compute_dict[\"all\"].values():\n                for real_atoms, basis_atoms in compute_list:\n                    label = labeler(mc, real_atoms, basis_atoms)\n                    if label in done_molecules:\n                        continue\n\n                    ghost_atoms = list(set(basis_atoms) - set(real_atoms))\n\n                    # Shift to zero-indexing\n                    real_atoms_0 = [x - 1 for x in real_atoms]\n                    ghost_atoms_0 = [x - 1 for x in ghost_atoms]\n                    mol = self.molecule.get_fragment(real_atoms_0, ghost_atoms_0, orient=False, group_fragments=False)\n                    mol = mol.copy(update={\"fix_com\": True, \"fix_orientation\": True})\n\n                    # if self.embedding_charges:\n                    #    embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1]))\n                    #    charges = []\n                    #    for frag in embedding_frags:\n                    #        positions = self.molecule.extract_subsets(frag).geometry().np.tolist()\n                    #        charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])])\n                    #    data['keywords']['function_kwargs'].update({'external_potentials': charges})\n\n                    done_molecules.add(label)\n                    yield mc, label, mol\n\n    def _assemble_nbody_components(\n        self,\n        property_label: str,\n        component_results: Dict[str, Union[float, np.ndarray]],\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Assembles N-body components for a single derivative level and a single model chemistry level\n        into interaction quantities according to requested BSSE treatment(s).\n        \"\"\"\n\n        # which level are we assembling?\n        delabeled = [delabeler(k) for k in component_results.keys()]\n        mc_level_labels = {x[0] for x in delabeled}\n\n        if len(mc_level_labels) != 1:\n            raise RuntimeError(f\"Multiple model chemistries passed into _assemble_nbody_components: {mc_level_labels}\")\n\n        mc_level = mc_level_labels.pop()\n        if mc_level not in self.mc_levels:\n            raise RuntimeError(f\"Model chemistry {mc_level} not found in {self.mc_levels}\")\n\n        # get the range of nbodies and the required calculations for this level\n        bsse_type = self.bsse_type\n        return_bsse_type = self.return_bsse_type\n        nbodies = self.nbodies_per_mc_level[mc_level]\n        if \"supersystem\" in nbodies:\n            nbodies = list(range(1, self.max_nbody + 1))\n            bsse_type = [BsseEnum.nocp]\n            return_bsse_type = BsseEnum.nocp\n\n        max_nbody = max(nbodies)\n        compute_dict = self.compute_map[mc_level]\n\n        if not all_same_shape(component_results.values()):\n            raise ValueError(\"All values in data dictionary must have the same shape.\")\n\n        # Use first data value to determine shape\n        first_key = next(iter(component_results.keys()))\n        property_shape = find_shape(component_results[first_key])\n\n        # Accumulation dictionaries\n        # * {bsse_type}_by_level is filled by sum_cluster_data to contain for NOCP\n        #   &amp; CP the summed total energies (or other property) of each nb-body. That is:\n        #   * NOCP: {1: 1b@1b,    2: 2b@2b,      ..., max_nbody: max_nbody-b@max_nbody-b} and\n        #   * CP:   {1: 1b@nfr-b, 2: 2b@nfr-b,   ..., max_nbody: max_nbody-b@nfr-b}.\n        #   VMFC bookkeeping is different. For key 1 it contains the summed 1b total energies.\n        #   But for higher keys, it contains each nb-body (non-additive) contribution to the energy.\n        #   * VMFC: {1: 1b@1b,    2: 2b contrib, ..., max_nbody: max_nbody-b contrib}\n        cp_by_level = {n: shaped_zero(property_shape) for n in range(1, nbodies[-1] + 1)}\n        nocp_by_level = {n: shaped_zero(property_shape) for n in range(1, nbodies[-1] + 1)}\n        vmfc_by_level = {n: shaped_zero(property_shape) for n in range(1, nbodies[-1] + 1)}\n\n        # * {bsse_type}_body_dict is usually filled with total energies (or other property).\n        #   Multiple model chemistry levels may be involved.\n        #   Generally, all consecutive keys between 1 and max_nbody will be present in the body_dict,\n        #   but if supersystem_ie_only=T, only 1b and nfr-b are present, or if \"supersystem\" in levels, ???\n        #   * TOT: {1: 1b@1b, 2: 2b tot prop with bsse_type treatment, ..., max_nbody: max_nbody-b tot prop with bsse_type treatment}\n        #   If 1b@1b (monomers in monomer basis) aren't available, which can happen when return_total_data=F\n        #   and 1b@1b aren't otherwise needed, body_dict contains interaction energies (or other property).\n        #   * IE: {1: shaped_zero, 2: 2b interaction prop using bsse_type, ..., max_nbody: max_nbody-b interaction prop using bsse_type}\n        #   For both TOT and IE cases, body_dict values are cummulative, not additive. For TOT, total,\n        #   interaction, and contribution data in ManyBodyResultProperties can be computed in\n        #   collect_vars. For IE, interaction and contribution data can be computed.\n        cp_body_dict = {n: shaped_zero(property_shape) for n in range(1, nbodies[-1] + 1)}\n        nocp_body_dict = {n: shaped_zero(property_shape) for n in range(1, nbodies[-1] + 1)}\n        vmfc_body_dict = {n: shaped_zero(property_shape) for n in range(1, nbodies[-1] + 1)}\n\n        # Sum up all of the levels\n        # * compute_dict[bt][nb] holds all the computations needed to compute nb\n        #   *not* all the nb-level computations, so build the latter\n        cp_compute_list = {nb: set() for nb in range(1, nbodies[-1] + 1)}\n        nocp_compute_list = {nb: set() for nb in range(1, nbodies[-1] + 1)}\n\n        for nb in nbodies:\n            for v in compute_dict[\"cp\"][nb]:\n                if len(v[1]) != 1:\n                    cp_compute_list[len(v[0])].add(v)\n            for w in compute_dict[\"nocp\"][nb]:\n                nocp_compute_list[len(w[0])].add(w)\n\n        for nb in range(1, nbodies[-1] + 1):\n            cp_by_level[nb] = sum_cluster_data(component_results, cp_compute_list[nb], mc_level)\n            nocp_by_level[nb] = sum_cluster_data(component_results, nocp_compute_list[nb], mc_level)\n            if nb in compute_dict[\"vmfc_levels\"]:\n                vmfc_by_level[nb] = sum_cluster_data(\n                    component_results, compute_dict[\"vmfc_levels\"][nb], mc_level, vmfc=True, nb=nb\n                )\n\n        # Extract data for monomers in monomer basis for CP total data\n        if 1 in nbodies:\n            monomers_in_monomer_basis = [v for v in compute_dict[\"nocp\"][1] if len(v[1]) == 1]\n            monomer_sum = sum_cluster_data(component_results, set(monomers_in_monomer_basis), mc_level)\n        else:\n            monomer_sum = shaped_zero(property_shape)\n\n        # Compute cp\n        if BsseEnum.cp in bsse_type:\n            for nb in range(1, nbodies[-1] + 1):\n                if nb == self.nfragments:\n                    cp_body_dict[nb] = cp_by_level[nb] - bsse\n                    continue\n\n                for k in range(1, nb + 1):\n                    take_nk = math.comb(self.nfragments - k - 1, nb - k)\n                    sign = (-1) ** (nb - k)\n                    cp_body_dict[nb] += take_nk * sign * cp_by_level[k]\n\n                if nb == 1:\n                    bsse = cp_body_dict[nb] - monomer_sum\n                    cp_body_dict[nb] = copy_value(monomer_sum)\n                else:\n                    cp_body_dict[nb] -= bsse\n\n        # Compute nocp\n        if BsseEnum.nocp in bsse_type:\n            for nb in range(1, nbodies[-1] + 1):\n                if nb == self.nfragments:\n                    nocp_body_dict[nb] = nocp_by_level[nb]\n                    continue\n\n                for k in range(1, nb + 1):\n                    take_nk = math.comb(self.nfragments - k - 1, nb - k)\n                    sign = (-1) ** (nb - k)\n                    nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]\n\n        # Compute vmfc\n        if BsseEnum.vmfc in bsse_type:\n            for nb in nbodies:\n                for k in range(1, nb + 1):\n                    vmfc_body_dict[nb] += vmfc_by_level[k]\n\n        # Collect specific and generalized returns\n        results = {\n            f\"cp_{property_label}_body_dict\": cp_body_dict,\n            f\"nocp_{property_label}_body_dict\": nocp_body_dict,\n            f\"vmfc_{property_label}_body_dict\": vmfc_body_dict,\n        }\n\n        # Overall return body dict &amp; value for this property\n        results[f\"{property_label}_body_dict\"] = results[f\"{return_bsse_type.value}_{property_label}_body_dict\"]\n        results[f\"ret_{property_label}\"] = copy_value(results[f\"{property_label}_body_dict\"][max_nbody])\n\n        if not self.return_total_data:\n            results[f\"ret_{property_label}\"] -= results[f\"{property_label}_body_dict\"][1]\n\n        return results\n\n    def _analyze(\n        self,\n        property_label: str,\n        property_results: Dict[str, Union[float, np.ndarray]],  # Label to results\n    ):\n        # Initialize with zeros\n        if not all_same_shape(property_results.values()):\n            raise ValueError(\"All values in data dictionary must have the same shape.\")\n\n        # Use first data value to determine shape\n        first_key = next(iter(property_results.keys()))\n        property_shape = find_shape(property_results[first_key])\n\n        property_result = shaped_zero(property_shape)\n        property_body_dict = {bt.value: {} for bt in self.bsse_type}\n        property_body_contribution = {bt.value: {} for bt in self.bsse_type}\n\n        # results per model chemistry\n        mc_results = {}\n        species_results = {}\n\n        # sort by nbody level, ignore supersystem\n        sorted_nbodies = [(k, v) for k, v in self.nbodies_per_mc_level.items() if v != [\"supersystem\"]]\n        sorted_nbodies = sorted(sorted_nbodies, reverse=True, key=lambda x: x[1])\n        for mc_label, nbody_list in sorted_nbodies:\n            # filter to only one model chemistry\n            filtered_results = {k: v for k, v in property_results.items() if delabeler(k)[0] == mc_label}\n\n            if not filtered_results:\n                if nbody_list == [1]:\n                    # Note A.2: Note A.1 holds, but for the special case of CP-only\n                    #   and rtd=False and multilevel with a separate level for\n                    #   1-body, the skipped tasks run afoul of sanity checks, so\n                    #   we'll add a dummy result.\n                    filtered_results = {labeler(mc_label, [1000], [1000]): shaped_zero(property_shape)}\n                else:\n                    raise RuntimeError(f\"No data found for model chemistry {mc_label}\")\n\n            nb_component_results = self._assemble_nbody_components(property_label, filtered_results)\n            mc_results[mc_label] = nb_component_results\n\n            for n in nbody_list[::-1]:\n                property_bsse_dict = {bt.value: shaped_zero(property_shape) for bt in self.bsse_type}\n\n                for m in range(n - 1, n + 1):\n                    if m == 0:\n                        continue\n\n                    # Subtract the (n-1)-body contribution from the n-body contribution to get the n-body effect\n                    sign = (-1) ** (1 - m // n)\n                    for bt in self.bsse_type:\n                        property_bsse_dict[bt.value] += (\n                            sign * mc_results[mc_label][f\"{bt.value}_{property_label}_body_dict\"][m]\n                        )\n\n                property_result += property_bsse_dict[self.return_bsse_type]\n                for bt in self.bsse_type:\n                    property_body_contribution[bt.value][n] = property_bsse_dict[bt.value]\n\n        if self.has_supersystem:\n            # Get the MC label for supersystem tasks\n            supersystem_mc_level = self.levels[\"supersystem\"]\n\n            # Super system recovers higher order effects at a lower level\n            frag_range = tuple(range(1, self.nfragments + 1))\n\n            ss_cresults = {k: v for k, v in property_results.items() if delabeler(k)[0] == supersystem_mc_level}\n            ss_component_results = self._assemble_nbody_components(property_label, ss_cresults)\n            mc_results[supersystem_mc_level] = ss_component_results\n\n            # Compute components at supersystem level of theory\n            ss_label = labeler(supersystem_mc_level, frag_range, frag_range)\n            supersystem_result = property_results[ss_label]\n            property_result += supersystem_result - ss_component_results[f\"{property_label}_body_dict\"][self.max_nbody]\n\n            for bt in self.bsse_type:\n                property_body_contribution[bt][self.nfragments] = (\n                    supersystem_result - ss_component_results[f\"{property_label}_body_dict\"][self.max_nbody]\n                )\n\n        for bt in self.bsse_type:\n            bstr = bt.value\n            for n in property_body_contribution[bstr]:\n                property_body_dict[bstr][n] = sum(\n                    [\n                        property_body_contribution[bstr][i]\n                        for i in range(1, n + 1)\n                        if i in property_body_contribution[bstr]\n                    ]\n                )\n\n        if not self.return_total_data:\n            # Remove monomer contribution for interaction data\n            property_result -= property_body_dict[self.return_bsse_type][1]\n\n        nbody_results = {\n            f\"ret_{property_label}\": property_result,\n            f\"{property_label}_body_dict\": property_body_dict,\n            \"mc_results\": mc_results,\n        }\n        return nbody_results\n\n    def analyze(\n        self,\n        component_results: Dict[str, Dict[str, Union[float, np.ndarray]]],\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        component_results\n            Nested dictionary with results from all individual molecular system\n            calculations, including all subsystem/basis combinations, all model\n            chemistries, and all properties (e.g., e/g/h).\n\n            For example, the below is the format for a nocp gradient run on a\n            helium dimer with 1-body at CCSD and 2-body at MP2. The outer string\n            key can be generated with the ``qcmanybody.utils.labeler`` function.\n            The inner string key is any property; QCManyBody presently knows how\n            to process energy/gradient/Hessian.\n\n            {'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])},\n            }\n\n        Return\n        ------\n\n        \"\"\"\n\n        # All properties that were passed to us\n        # * seed with \"energy\" so free/no-op jobs can process\n        available_properties: Set[str] = {\"energy\"}\n        for property_data in component_results.values():\n            available_properties.update(property_data.keys())\n\n        # reorganize to component_results_inv[property][label] = 1.23\n        component_results_inv = {k: {} for k in available_properties}\n\n        for cluster_label, property_data in component_results.items():\n            for property_label, property_value in property_data.items():\n                component_results_inv[property_label][cluster_label] = property_value\n\n        # Remove any missing data\n        component_results_inv = {k: v for k, v in component_results_inv.items() if v}\n        if not component_results_inv:\n            # Note B: Rarely, \"no results\" is expected, like for CP-only,\n            #   rtd=False, and max_nbody=1. We'll add a dummy entry so\n            #   processing can continue.\n            component_results_inv[\"energy\"] = {'[\"dummy\", [1000], [1000]]': 0.0}\n\n        # Actually analyze\n        is_embedded = bool(self.embedding_charges)\n        component_properties = defaultdict(dict)\n        all_results = {}\n        nbody_dict = {}\n        stdout = \"\"\n#        all_results[\"energy_body_dict\"] = {\"cp\": {1: 0.0}}\n\n        for property_label, property_results in component_results_inv.items():\n            # Expand gradient and hessian\n            if property_label == \"gradient\":\n                property_results = {k: self.resize_gradient(v, delabeler(k)[2]) for k, v in property_results.items()}\n            if property_label == \"hessian\":\n                property_results = {k: self.resize_hessian(v, delabeler(k)[2]) for k, v in property_results.items()}\n\n            r = self._analyze(property_label, property_results)\n            for k, v in property_results.items():\n                component_properties[k][\"calcinfo_natom\"] = len(self.molecule.symbols)\n                component_properties[k][f\"return_{property_label}\"] = v\n            all_results.update(r)\n\n        for bt in self.bsse_type:\n            stdout += print_nbody_energy(\n                all_results[\"energy_body_dict\"][bt],\n                f\"{bt.formal()} ({bt.abbr()})\",\n                self.nfragments,\n                is_embedded,\n                self.supersystem_ie_only,\n                self.max_nbody if self.has_supersystem else None,\n            )\n\n        for property_label in available_properties:\n            for bt in self.bsse_type:\n                nbody_dict.update(\n                    collect_vars(\n                        bt.upper(),\n                        property_label.upper(),\n                        all_results[f\"{property_label}_body_dict\"][bt],\n                        self.max_nbody,\n                        is_embedded,\n                        self.supersystem_ie_only,\n                        self.has_supersystem,\n                    )\n                )\n\n        all_results[\"results\"] = nbody_dict\n        all_results[\"component_properties\"] = component_properties\n\n        # Make dictionary with \"1cp\", \"2cp\", etc\n        ebd = all_results[\"energy_body_dict\"]\n        all_results[\"energy_body_dict\"] = {str(k) + bt: v for bt in ebd for k, v in ebd[bt].items()}\n        all_results[\"stdout\"] = stdout\n\n        return all_results\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCalculator.analyze","title":"<code>analyze(component_results)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>component_results</code> <code>Dict[str, Dict[str, Union[float, ndarray]]]</code> <p>Nested dictionary with results from all individual molecular system calculations, including all subsystem/basis combinations, all model chemistries, and all properties (e.g., e/g/h).</p> <p>For example, the below is the format for a nocp gradient run on a helium dimer with 1-body at CCSD and 2-body at MP2. The outer string key can be generated with the <code>qcmanybody.utils.labeler</code> function. The inner string key is any property; QCManyBody presently knows how to process energy/gradient/Hessian.</p> <p>{'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},  '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])}, }</p> required Return Source code in <code>qcmanybody/manybody.py</code> <pre><code>    def analyze(\n        self,\n        component_results: Dict[str, Dict[str, Union[float, np.ndarray]]],\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        component_results\n            Nested dictionary with results from all individual molecular system\n            calculations, including all subsystem/basis combinations, all model\n            chemistries, and all properties (e.g., e/g/h).\n\n            For example, the below is the format for a nocp gradient run on a\n            helium dimer with 1-body at CCSD and 2-body at MP2. The outer string\n            key can be generated with the ``qcmanybody.utils.labeler`` function.\n            The inner string key is any property; QCManyBody presently knows how\n            to process energy/gradient/Hessian.\n\n            {'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])},\n            }\n\n        Return\n        ------\n\n        \"\"\"\n\n        # All properties that were passed to us\n        # * seed with \"energy\" so free/no-op jobs can process\n        available_properties: Set[str] = {\"energy\"}\n        for property_data in component_results.values():\n            available_properties.update(property_data.keys())\n\n        # reorganize to component_results_inv[property][label] = 1.23\n        component_results_inv = {k: {} for k in available_properties}\n\n        for cluster_label, property_data in component_results.items():\n            for property_label, property_value in property_data.items():\n                component_results_inv[property_label][cluster_label] = property_value\n\n        # Remove any missing data\n        component_results_inv = {k: v for k, v in component_results_inv.items() if v}\n        if not component_results_inv:\n            # Note B: Rarely, \"no results\" is expected, like for CP-only,\n            #   rtd=False, and max_nbody=1. We'll add a dummy entry so\n            #   processing can continue.\n            component_results_inv[\"energy\"] = {'[\"dummy\", [1000], [1000]]': 0.0}\n\n        # Actually analyze\n        is_embedded = bool(self.embedding_charges)\n        component_properties = defaultdict(dict)\n        all_results = {}\n        nbody_dict = {}\n        stdout = \"\"\n#        all_results[\"energy_body_dict\"] = {\"cp\": {1: 0.0}}\n\n        for property_label, property_results in component_results_inv.items():\n            # Expand gradient and hessian\n            if property_label == \"gradient\":\n                property_results = {k: self.resize_gradient(v, delabeler(k)[2]) for k, v in property_results.items()}\n            if property_label == \"hessian\":\n                property_results = {k: self.resize_hessian(v, delabeler(k)[2]) for k, v in property_results.items()}\n\n            r = self._analyze(property_label, property_results)\n            for k, v in property_results.items():\n                component_properties[k][\"calcinfo_natom\"] = len(self.molecule.symbols)\n                component_properties[k][f\"return_{property_label}\"] = v\n            all_results.update(r)\n\n        for bt in self.bsse_type:\n            stdout += print_nbody_energy(\n                all_results[\"energy_body_dict\"][bt],\n                f\"{bt.formal()} ({bt.abbr()})\",\n                self.nfragments,\n                is_embedded,\n                self.supersystem_ie_only,\n                self.max_nbody if self.has_supersystem else None,\n            )\n\n        for property_label in available_properties:\n            for bt in self.bsse_type:\n                nbody_dict.update(\n                    collect_vars(\n                        bt.upper(),\n                        property_label.upper(),\n                        all_results[f\"{property_label}_body_dict\"][bt],\n                        self.max_nbody,\n                        is_embedded,\n                        self.supersystem_ie_only,\n                        self.has_supersystem,\n                    )\n                )\n\n        all_results[\"results\"] = nbody_dict\n        all_results[\"component_properties\"] = component_properties\n\n        # Make dictionary with \"1cp\", \"2cp\", etc\n        ebd = all_results[\"energy_body_dict\"]\n        all_results[\"energy_body_dict\"] = {str(k) + bt: v for bt in ebd for k, v in ebd[bt].items()}\n        all_results[\"stdout\"] = stdout\n\n        return all_results\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCalculator.format_calc_plan","title":"<code>format_calc_plan(sset='all')</code>","text":"<p>Formulate per-modelchem and per-body job count data and summary text.</p> <p>Parameters:</p> Name Type Description Default <code>sset</code> <code>str</code> <p>Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.</p> <code>'all'</code> <p>Returns:</p> Type Description <code>info</code> <p>A text summary with per- model chemistry and per- n-body-level job counts.</p> <code>Dict[str, Dict[int, int]]</code> <p>Data structure with outer key mc-label, inner key 1-indexed n-body, value job count.</p> Source code in <code>qcmanybody/manybody.py</code> <pre><code>def format_calc_plan(self, sset: str = \"all\") -&gt; Tuple[str, Dict[str, Dict[int, int]]]:\n    \"\"\"Formulate per-modelchem and per-body job count data and summary text.\n\n    Parameters\n    ----------\n    sset\n        Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.\n\n    Returns\n    -------\n    info\n        A text summary with per- model chemistry and per- n-body-level job counts.\n    Dict[str, Dict[int, int]]\n        Data structure with outer key mc-label, inner key 1-indexed n-body, value job count.\n    \"\"\"\n    # Rearrange compute_list from key nb having values (species) to compute all of that nb\n    #   to key nb having values counting that nb.\n    compute_list_count = {}\n    for mc, compute_dict in self.compute_map.items():\n        compute_list_count[mc] = {}\n        for sub in compute_dict:  # all, nocp, cp, vmfc\n            all_calcs = set().union(*compute_dict[sub].values())\n            compute_list_count[mc][sub] = Counter([len(frag) for (frag, _) in all_calcs])\n\n    info = []\n    for mc, counter in compute_list_count.items():\n        all_counter = counter[\"all\"]\n        info.append(f\"    Model chemistry \\\"{mc}\\\" (???):    {sum(all_counter.values())}\")\n        for nb, count in sorted(all_counter.items()):\n            other_counts = [f\"{sub}: {counter[sub][nb]}\" for sub in [\"nocp\", \"cp\", \"vmfc_compute\"]]\n            info.append(f\"        Number of {nb}-body computations: {count:6} ({', '.join(other_counts)})\")\n        info.append(\"\")\n    info = \"\\n\".join(info)\n\n    logger.info(info)\n    return info, {mc: dsset[sset] for mc, dsset in compute_list_count.items()}\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCalculator.iterate_molecules","title":"<code>iterate_molecules()</code>","text":"<p>Iterate over all the molecules needed for the computation.</p> <p>Yields model chemistry, label, and molecule.</p> Source code in <code>qcmanybody/manybody.py</code> <pre><code>def iterate_molecules(self) -&gt; Iterable[Tuple[str, str, Molecule]]:\n    \"\"\"Iterate over all the molecules needed for the computation.\n\n    Yields model chemistry, label, and molecule.\n    \"\"\"\n\n    done_molecules = set()\n\n    for mc, compute_dict in self.compute_map.items():\n        # TODO - this is a bit of a hack. Lots of duplication when reaching higher nbody\n        for compute_list in compute_dict[\"all\"].values():\n            for real_atoms, basis_atoms in compute_list:\n                label = labeler(mc, real_atoms, basis_atoms)\n                if label in done_molecules:\n                    continue\n\n                ghost_atoms = list(set(basis_atoms) - set(real_atoms))\n\n                # Shift to zero-indexing\n                real_atoms_0 = [x - 1 for x in real_atoms]\n                ghost_atoms_0 = [x - 1 for x in ghost_atoms]\n                mol = self.molecule.get_fragment(real_atoms_0, ghost_atoms_0, orient=False, group_fragments=False)\n                mol = mol.copy(update={\"fix_com\": True, \"fix_orientation\": True})\n\n                # if self.embedding_charges:\n                #    embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1]))\n                #    charges = []\n                #    for frag in embedding_frags:\n                #        positions = self.molecule.extract_subsets(frag).geometry().np.tolist()\n                #        charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])])\n                #    data['keywords']['function_kwargs'].update({'external_potentials': charges})\n\n                done_molecules.add(label)\n                yield mc, label, mol\n</code></pre>"},{"location":"core-interface/","title":"Core Interface","text":"<p>The core interface of QCManyBody is designed to allow for more flexibility in how the calculations are run. The primary responsibilities of the core interface are:</p> <ol> <li>Given a molecule and desired levels of MBE, return the fragments and levels that must be computed for each fragment</li> <li>Given a dictionary of the results of those computations, analyze those results and calculate the desired manybody properties</li> </ol> <p>Note that the user is expected to run the calculations themselves, and the core interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#using-the-core-interface","title":"Using the core interface","text":"<p>The core interface is accessed through the <code>ManyBodyCalculator</code> class.</p> <p>The first step is to create a molecule. This molecule is a QCElemental molecule object, and must contain fragments.</p> <pre><code>import qcmanybody as qcmb\nimport qcelemental as qcel\n\n# Create a molecule with 3 hydrogen atoms, each as its own fragment\nmol = qcel.models.Molecule(symbols=['h', 'h', 'h'],\n                           geometry=[[0,0,0],[0,0,2],[0,0,4]],\n                           fragments=[[0], [1], [2]])\n</code></pre> <p>Next, create a <code>ManyBodyCalculator</code> object. This object is constructed using the molecule, the desired BSSE correction, levels of MBE, and other options of the MBE.</p> <pre><code>mbc = qcmb.ManyBodyCalculator(\n    molecule=mol,\n    bsse_type=['cp'],\n    levels={1: 'mp2/aug-cc-pvtz', 2: 'b3lyp/def2-svp', 3: 'hf/sto-3g'},\n    return_total_data=True,\n    supersystem_ie_only=False\n)\n</code></pre> <p>The <code>levels</code> option is a dictionary that specifies the n-body level as a key, then an arbitrary string as the description of the calculation to be performed at the n-body level. This string is termed the 'model chemistry' is completely arbitrary; it only has meaning to the user, and the user is expected to map these strings to some meaningful definition of a calculation.</p> <p>Note: The core interface is less flexible than the high-level interface when it comes to the <code>levels</code> option.     In the core interface, all levels must be accounted for (that is, keys must go from 1 to the maximum     nbody you would like to calculate). All levels must be present even if the model chemistry     is the same for all levels.</p> <p>For a complete discussion of the other options available in the <code>ManyBodyCalculator</code> object, see the keywords discussion the <code>ManyBodyCalculator API documentation</code>.</p> <p>The next step is to obtain the calculations to be run from the <code>ManyBodyCalculator</code> object. This is done with a python generator function <code>iterate_molecules</code> that returns a tuple. This tuple contains</p> <ol> <li>The string describing the calculation to be run (the model chemistry string, as defined in the <code>levels</code> dictionary)</li> <li>A label for the calculation. This label is opaque to the user but used to identify the calculation when analyzing the results.</li> <li>A <code>Molecule</code> object that contains the cluster of fragments to be computed.</li> </ol> <pre><code>calculation_results = {}\nfor model_chemistry, label, mol_cluster in mbc.iterate_molecules():\n    calculation_results[label] = run_calculation(mol_cluster, model_chemistry)\n</code></pre> <p>Note that it is entirely up to the user to run the calculation somehow - this level of interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#results-dictionary","title":"Results dictionary","text":"<p>The data returned from the calculations is expected to be stored in a nested dictionary. The level is the opaque label as given from the <code>QCManyBodyCalculator</code>. The second level is the name of the property.</p> <pre><code>calculation_results = {\n    'label1': {\n        'energy': -1.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]],\n    },\n    'label2': {\n        'energy': -2.0,\n        'gradient': [[4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n    'label3': {\n        'energy': -3.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n}\n</code></pre>"},{"location":"core-interface/#analysis","title":"Analysis","text":"<p>This result dictionary is all that is needed to perform the final analysis and calculation of the MBE properties.</p> <pre><code>final_results = mbc.analyze(calculation_results)\n</code></pre> <p>For a discussion about what the results contain, see the results documentation.</p>"},{"location":"high-level-interface/","title":"High-Level Interface","text":""},{"location":"keywords/","title":"Keywords and options","text":""},{"location":"keywords/#required","title":"Required","text":""},{"location":"keywords/#molecule","title":"Molecule","text":""},{"location":"keywords/#bsse_type","title":"bsse_type","text":""},{"location":"keywords/#levels-and-max_nbody","title":"levels and max_nbody","text":""},{"location":"keywords/#keywords-and-options_1","title":"Keywords and Options","text":"<p>Both the high-level interface and core interface share the same terminology with respect to options</p>"},{"location":"keywords/#return_total_data","title":"return_total_data","text":"<p>When set to true, the manybody calculation will return the total data (energy/gradient/hessian/property) of the system. If not, the return will only contain interaction data.</p> <p>Note that the calculation of counterpoise corrected total properties implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than. For some properties such as gradients and hessians, <code>return_total_data = False</code> is rarely useful.</p>"},{"location":"keywords/#supersystem_ie_only","title":"supersystem_ie_only","text":"<p>Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When false, each n-body level in the MBE up through <code>max_nbody</code> will be computed. When true (only allowed for <code>max_nbody = nfragments</code>), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body.</p> <p>When true, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code>; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers).</p> <p>This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code> Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings.</p>"}]}