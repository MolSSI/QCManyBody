{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QCManyBody Documentation","text":"<p>QCManyBody is a python package for running quantum chemistry manybody expansions and interaction calculations in a package-independent way.</p>"},{"location":"#installation","title":"Installation","text":"<p>QCManyBody is available from PyPI and from conda-forge.</p> <pre><code># Installation from PyPI\npip install qcmanybody\n\n# Installation from conda-forge\nconda install -c conda-forge qcmanybody\n</code></pre> <p>To install the latest development version directly from GitHub, you can use the following command:</p> <pre><code>pip install git+https://github.com/MolSSI/QCManyBody.git\n</code></pre>"},{"location":"#package-overview","title":"Package Overview","text":"<p>The package has two main interfaces. The high-level interface allows for a comprehensive workflow, where the user provides complete information about the calculation, including the full specification (method, basis set, etc.) of the manybody calculation. This is designed to work with QCEngine or other packages that implement the QCSchema.</p> <p>For more information, see High-level interface.</p> <p>QCManyBody also has a core low-level interface that allows for more flexibility in how the calculations are run. This interface generally takes a molecule and an arbitrary definition of quantum chemistry specifications, and expects the user to run them themselves.</p> <p>For more information, see Core interface.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Common Keywords and Options</li> <li>High-level Interface</li> <li>Core Interface</li> <li>Results</li> <li>How-To Guides</li> </ol>"},{"location":"api/","title":"API Documentation","text":"Source code in <code>qcmanybody/manybody.py</code> <pre><code>def __init__(\n    self,\n    molecule: Molecule,\n    bsse_type: Sequence[BsseEnum],\n    levels: Mapping[Union[int, Literal[\"supersystem\"]], str],\n    return_total_data: bool,\n    supersystem_ie_only: bool,\n    embedding_charges: Mapping[int, Sequence[float]],\n):\n    self.embedding_charges = embedding_charges\n    self.molecule = molecule\n    self.bsse_type = [BsseEnum(x) for x in bsse_type]\n    self.return_total_data = return_total_data\n    self.supersystem_ie_only = supersystem_ie_only\n    self.nfragments = len(molecule.fragments)\n\n    self.levels = levels\n\n    # Levels without supersystem\n    self.levels_no_ss = {int(k): v for k, v in levels.items() if k != \"supersystem\"}\n\n    # Just a set of all the modelchems\n    self.mc_levels = set(self.levels.values())\n\n    self.max_nbody = max(self.levels_no_ss.keys())\n\n    if len(self.bsse_type) == 0:\n        raise ValueError(\"No BSSE correction specified\")\n\n    if BsseEnum.vmfc in self.bsse_type and len(set(self.levels.values())) == 1:\n        # For single-modelchem VMFC, NOCP &amp; sometimes CP are produced for free\n        if BsseEnum.nocp not in self.bsse_type:\n            self.bsse_type.append(BsseEnum.nocp)\n        if BsseEnum.cp not in self.bsse_type and self.max_nbody == self.nfragments:\n            self.bsse_type.append(BsseEnum.cp)\n\n    self.return_bsse_type = self.bsse_type[0]\n\n    ###############################\n    # Build nbodies_per_mc_level\n    # TODO - use Lori's code\n    # TODO - dict to list of lists to handle non-contiguous levels\n    # TODO multilevel and supersystem_ie_only=T not allowed together\n    # TODO supersystem in levels is not to be trusted -- nfrag only and skips levels\n    max_level = max(self.levels_no_ss.keys())\n\n    if set(range(1, max_level + 1)) != set(self.levels_no_ss.keys()):\n        raise ValueError(f\"Levels must be contiguous from 1 to {max_level}\")\n\n    self.nbodies_per_mc_level: Dict[str, list] = {mc_level: [] for mc_level in self.mc_levels}\n    for k, v in self.levels_no_ss.items():\n        self.nbodies_per_mc_level[v].append(k)\n\n    self.nbodies_per_mc_level = {k: sorted(v) for k, v in self.nbodies_per_mc_level.items()}\n\n    # Supersystem is always at the end\n    if \"supersystem\" in levels:\n        ss_mc = levels[\"supersystem\"]\n        self.nbodies_per_mc_level[ss_mc].append(\"supersystem\")\n\n    # To be built on the fly\n    self.mc_compute_dict = None\n\n    if not np.array_equal(np.concatenate(self.molecule.fragments), np.arange(len(self.molecule.symbols))):\n        raise ValueError(\"\"\"QCManyBody: non-contiguous fragments could be implemented but aren't at present\"\"\")\n\n    # Build size and slices dictionaries. Assumes fragments are contiguous\n    self.fragment_size_dict = {}\n    self.fragment_slice_dict = {}\n    iat = 0\n    for ifr in range(1, self.nfragments + 1):\n        nat = len(self.molecule.fragments[ifr - 1])\n        self.fragment_size_dict[ifr] = nat\n        self.fragment_slice_dict[ifr] = slice(iat, iat + nat)\n        iat += nat\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCalculator.format_calc_plan","title":"format_calc_plan","text":"<pre><code>format_calc_plan(sset: str = 'all') -&gt; Tuple[str, Dict[str, Dict[int, int]]]\n</code></pre> <p>Formulate per-modelchem and per-body job count data and summary text.</p> <p>Parameters:</p> Name Type Description Default <code>sset</code> <code>str</code> <p>Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.</p> <code>'all'</code> <p>Returns:</p> Type Description <code>info</code> <p>A text summary with per- model chemistry and per- n-body-level job counts.</p> <code>Dict[str, Dict[int, int]]</code> <p>Data structure with outer key mc-label, inner key 1-indexed n-body, value job count.</p> Source code in <code>qcmanybody/manybody.py</code> <pre><code>def format_calc_plan(self, sset: str = \"all\") -&gt; Tuple[str, Dict[str, Dict[int, int]]]:\n    \"\"\"Formulate per-modelchem and per-body job count data and summary text.\n\n    Parameters\n    ----------\n    sset\n        Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.\n\n    Returns\n    -------\n    info\n        A text summary with per- model chemistry and per- n-body-level job counts.\n    Dict[str, Dict[int, int]]\n        Data structure with outer key mc-label, inner key 1-indexed n-body, value job count.\n    \"\"\"\n    # Rearrange compute_list from key nb having values (species) to compute all of that nb\n    #   to key nb having values counting that nb.\n    compute_list_count = {}\n    for mc, compute_dict in self.compute_map.items():\n        compute_list_count[mc] = {}\n        for sub in compute_dict:  # all, nocp, cp, vmfc\n            all_calcs = set().union(*compute_dict[sub].values())\n            compute_list_count[mc][sub] = Counter([len(frag) for (frag, _) in all_calcs])\n\n    info = []\n    for mc, counter in compute_list_count.items():\n        all_counter = counter[\"all\"]\n        info.append(f\"    Model chemistry \\\"{mc}\\\" (???):    {sum(all_counter.values())}\")\n        for nb, count in sorted(all_counter.items()):\n            other_counts = [f\"{sub}: {counter[sub][nb]}\" for sub in [\"nocp\", \"cp\", \"vmfc_compute\"]]\n            info.append(f\"        Number of {nb}-body computations: {count:6} ({', '.join(other_counts)})\")\n        info.append(\"\")\n    info = \"\\n\".join(info)\n\n    logger.info(info)\n    return info, {mc: dsset[sset] for mc, dsset in compute_list_count.items()}\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCalculator.iterate_molecules","title":"iterate_molecules","text":"<pre><code>iterate_molecules() -&gt; Iterable[Tuple[str, str, Molecule]]\n</code></pre> <p>Iterate over all the molecules needed for the computation.</p> <p>Yields model chemistry, label, and molecule.</p> Source code in <code>qcmanybody/manybody.py</code> <pre><code>def iterate_molecules(self) -&gt; Iterable[Tuple[str, str, Molecule]]:\n    \"\"\"Iterate over all the molecules needed for the computation.\n\n    Yields model chemistry, label, and molecule.\n    \"\"\"\n\n    done_molecules = set()\n\n    for mc, compute_dict in self.compute_map.items():\n        # TODO - this is a bit of a hack. Lots of duplication when reaching higher nbody\n        for compute_list in compute_dict[\"all\"].values():\n            for real_atoms, basis_atoms in compute_list:\n                label = labeler(mc, real_atoms, basis_atoms)\n                if label in done_molecules:\n                    continue\n\n                ghost_atoms = list(set(basis_atoms) - set(real_atoms))\n\n                # Shift to zero-indexing\n                real_atoms_0 = [x - 1 for x in real_atoms]\n                ghost_atoms_0 = [x - 1 for x in ghost_atoms]\n                mol = self.molecule.get_fragment(real_atoms_0, ghost_atoms_0, orient=False, group_fragments=False)\n                mol = mol.copy(update={\"fix_com\": True, \"fix_orientation\": True})\n\n                if self.embedding_charges:\n                    embedding_frags = list(set(range(1, self.nfragments + 1)) - set(basis_atoms))\n                    charges = []\n                    for ifr in embedding_frags:\n                        positions = self.molecule.get_fragment(ifr-1).geometry.tolist()\n                        charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[ifr])])\n                    mol.extras[\"embedding_charges\"] = charges\n\n                done_molecules.add(label)\n                yield mc, label, mol\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCalculator.analyze","title":"analyze","text":"<pre><code>analyze(component_results: Dict[str, Dict[str, Union[float, ndarray]]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>component_results</code> <code>Dict[str, Dict[str, Union[float, ndarray]]]</code> <p>Nested dictionary with results from all individual molecular system calculations, including all subsystem/basis combinations, all model chemistries, and all properties (e.g., e/g/h).</p> <p>For example, the below is the format for a nocp gradient run on a helium dimer with 1-body at CCSD and 2-body at MP2. The outer string key can be generated with the <code>qcmanybody.utils.labeler</code> function. The inner string key is any property; QCManyBody presently knows how to process energy/gradient/Hessian.</p> <p>{'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},  '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])}, }</p> required Return Source code in <code>qcmanybody/manybody.py</code> <pre><code>    def analyze(\n        self,\n        component_results: Dict[str, Dict[str, Union[float, np.ndarray]]],\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        component_results\n            Nested dictionary with results from all individual molecular system\n            calculations, including all subsystem/basis combinations, all model\n            chemistries, and all properties (e.g., e/g/h).\n\n            For example, the below is the format for a nocp gradient run on a\n            helium dimer with 1-body at CCSD and 2-body at MP2. The outer string\n            key can be generated with the ``qcmanybody.utils.labeler`` function.\n            The inner string key is any property; QCManyBody presently knows how\n            to process energy/gradient/Hessian.\n\n            {'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])},\n            }\n\n        Return\n        ------\n\n        \"\"\"\n\n        # All properties that were passed to us\n        # * seed with \"energy\" so free/no-op jobs can process\n        available_properties: Set[str] = {\"energy\"}\n        for property_data in component_results.values():\n            available_properties.update(property_data.keys())\n\n        # reorganize to component_results_inv[property][label] = 1.23\n        component_results_inv = {k: {} for k in available_properties}\n\n        for cluster_label, property_data in component_results.items():\n            for property_label, property_value in property_data.items():\n                component_results_inv[property_label][cluster_label] = property_value\n\n        # Remove any missing data\n        component_results_inv = {k: v for k, v in component_results_inv.items() if v}\n        if not component_results_inv:\n            # Note B: Rarely, \"no results\" is expected, like for CP-only,\n            #   rtd=False, and max_nbody=1. We'll add a dummy entry so\n            #   processing can continue.\n            component_results_inv[\"energy\"] = {'[\"dummy\", [1000], [1000]]': 0.0}\n\n        # Actually analyze\n        is_embedded = bool(self.embedding_charges)\n        component_properties = defaultdict(dict)\n        all_results = {}\n        nbody_dict = {}\n        stdout = \"\"\n#        all_results[\"energy_body_dict\"] = {\"cp\": {1: 0.0}}\n\n        for property_label, property_results in component_results_inv.items():\n            # Expand gradient and hessian\n            if property_label == \"gradient\":\n                property_results = {k: self.resize_gradient(v, delabeler(k)[2]) for k, v in property_results.items()}\n            if property_label == \"hessian\":\n                property_results = {k: self.resize_hessian(v, delabeler(k)[2]) for k, v in property_results.items()}\n\n            r = self._analyze(property_label, property_results)\n            for k, v in property_results.items():\n                component_properties[k][\"calcinfo_natom\"] = len(self.molecule.symbols)\n                component_properties[k][f\"return_{property_label}\"] = v\n            all_results.update(r)\n\n        for bt in self.bsse_type:\n            stdout += print_nbody_energy(\n                all_results[\"energy_body_dict\"][bt],\n                f\"{bt.formal()} ({bt.abbr()})\",\n                self.nfragments,\n                is_embedded,\n                self.supersystem_ie_only,\n                self.max_nbody if self.has_supersystem else None,\n            )\n\n        for property_label in available_properties:\n            for bt in self.bsse_type:\n                nbody_dict.update(\n                    collect_vars(\n                        bt.upper(),\n                        property_label.upper(),\n                        all_results[f\"{property_label}_body_dict\"][bt],\n                        self.max_nbody,\n                        is_embedded,\n                        self.supersystem_ie_only,\n                        self.has_supersystem,\n                    )\n                )\n\n        all_results[\"results\"] = nbody_dict\n        all_results[\"component_properties\"] = component_properties\n\n        # Make dictionary with \"1cp\", \"2cp\", etc\n        ebd = all_results[\"energy_body_dict\"]\n        all_results[\"energy_body_dict\"] = {str(k) + bt: v for bt in ebd for k, v in ebd[bt].items()}\n        all_results[\"stdout\"] = stdout\n\n        return all_results\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v010-2024-04-24","title":"v0.1.0 / 2024-04-24","text":""},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Runs CP, NoCP, VMFC energies, gradients, and Hessians. @bennybp @loriab</li> </ul>"},{"location":"core-interface/","title":"Core Interface","text":"<p>The core interface of QCManyBody is designed to allow for more flexibility in how the calculations are run. The primary responsibilities of the core interface are:</p> <ol> <li>Given a molecule and desired levels of MBE, return the fragments and levels that must be computed for each fragment</li> <li>Given a dictionary of the results of those computations, analyze those results and calculate the desired manybody properties</li> </ol> <p>Note that the user is expected to run the calculations themselves, and the core interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#using-the-core-interface","title":"Using the core interface","text":"<p>The core interface is accessed through the <code>ManyBodyCalculator</code> class.</p> <p>The first step is to create a molecule. This molecule is a QCElemental molecule object, and must contain fragments. (see also: moleule input)</p> <pre><code>import qcmanybody as qcmb\nimport qcelemental as qcel\n\n# Create a molecule with 3 hydrogen atoms, each as its own fragment\nmol = qcel.models.Molecule(symbols=['h', 'h', 'h'],\n                           geometry=[[0,0,0],[0,0,2],[0,0,4]],\n                           fragments=[[0], [1], [2]])\n</code></pre> <p>Next, create a <code>ManyBodyCalculator</code> object. This object is constructed using the molecule, the desired BSSE correction, levels of MBE, and other options of the MBE.</p> <pre><code>mbc = qcmb.ManyBodyCalculator(\n    molecule=mol,\n    bsse_type=['cp'],\n    levels={1: 'mp2/aug-cc-pvtz', 2: 'b3lyp/def2-svp', 3: 'hf/sto-3g'},\n    return_total_data=True,\n    supersystem_ie_only=False\n)\n</code></pre> <p>The <code>levels</code> option is a dictionary that specifies the n-body level as a key, then an arbitrary string as the description of the calculation to be performed at the n-body level. This string is termed the 'model chemistry' is completely arbitrary; it only has meaning to the user, and the user is expected to map these strings to some meaningful definition of a calculation.</p> <p>Note: The core interface is less flexible than the high-level interface when it comes to the <code>levels</code> option.     In the core interface, all levels must be accounted for (that is, keys must go from 1 to the maximum     nbody you would like to calculate). All levels must be present even if the model chemistry     is the same for all levels.</p> <p>For a complete discussion of the other options available in the <code>ManyBodyCalculator</code> object, see the keywords discussion the <code>ManyBodyCalculator API documentation</code>.</p> <p>The next step is to obtain the calculations to be run from the <code>ManyBodyCalculator</code> object. This is done with a python generator function <code>iterate_molecules</code> that returns a tuple. This tuple contains</p> <ol> <li>The string describing the calculation to be run (the model chemistry string, as defined in the <code>levels</code> dictionary)</li> <li>A label for the calculation. This label is opaque to the user but used to identify the calculation when analyzing the results.</li> <li>A <code>Molecule</code> object that contains the cluster of fragments to be computed.</li> </ol> <pre><code>calculation_results = {}\nfor model_chemistry, label, mol_cluster in mbc.iterate_molecules():\n    calculation_results[label] = run_calculation(mol_cluster, model_chemistry)\n</code></pre> <p>Note that it is entirely up to the user to run the calculation somehow - this level of interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#results-dictionary","title":"Results dictionary","text":"<p>The data returned from the calculations is expected to be stored in a nested dictionary. The level is the opaque label as given from the <code>QCManyBodyCalculator</code>. The second level is the name of the property.</p> <pre><code>calculation_results = {\n    'label1': {\n        'energy': -1.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]],\n    },\n    'label2': {\n        'energy': -2.0,\n        'gradient': [[4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n    'label3': {\n        'energy': -3.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n}\n</code></pre>"},{"location":"core-interface/#analysis","title":"Analysis","text":"<p>This result dictionary is all that is needed to perform the final analysis and calculation of the MBE properties.</p> <pre><code>final_results = mbc.analyze(calculation_results)\n</code></pre> <p>For a discussion about what the results contain, see the results documentation.</p>"},{"location":"high-level-interface/","title":"High-Level Interface","text":""},{"location":"keywords/","title":"Keywords and options","text":""},{"location":"keywords/#required","title":"Required","text":""},{"location":"keywords/#molecule","title":"Molecule","text":"<p>The molecule used by QCManyBody is a QCElemental Molecule object. The only requirement for use in QCManyBody is that the molecule has multiple fragments. It is these fragments that will be used in the many-body expansion.</p> <p>Examples:</p> <pre><code>from qcelemental.models import Molecule\n\n# Molecule with 3 hydrogen atoms, each as its own fragment\nh3 = Molecule(symbols=['h', 'h', 'h'],\n              geometry=[[0,0,0],[0,0,2],[0,0,4]],\n              fragments=[[0], [1], [2]])\n\n\n# Water tetramer\nwater4 = Molecule(symbols=['o', 'h', 'h', 'o', 'h', 'h', 'o', 'h', 'h', 'o', 'h', 'h'],\n                  geometry=[[-2.8, -1.2, -0.2], [-1.1, -2.1, -0.0], [-3.8, -2.1,  1.1],\n                            [-2.8, -1.2, -2.2], [-1.1, -2.1, -2.0], [-3.8, -2.1, -1.1],\n                            [-2.8, -1.2, -4.2], [-1.1, -2.1, -4.0], [-3.8, -2.1, -3.1],\n                            [-2.8, -1.2, -6.2], [-1.1, -2.1, -6.0], [-3.8, -2.1, -5.1]],\n                          fragments=[[0,1,2], [3,4,5], [6,7,8], [9,10,11]])\n\n# Water trimer, using the from_data function\n# the -- is used to separate fragments\nwater3 = Molecule.from_data(\n\"\"\"\nO      -2.76373224  -1.24377706  -0.15444566\nH      -1.12357791  -2.06227970  -0.05243799\nH      -3.80792362  -2.08705525   1.06090407\n--\nO       2.46924614  -1.75437739  -0.17092884\nH       3.76368260  -2.21425403   1.00846104\nH       2.30598330   0.07098445  -0.03942473\n--\nO       0.29127930   3.00875625   0.20308515\nH      -1.21253048   1.95820900   0.10303324\nH       0.10002049   4.24958115  -1.10222079\nunits bohr\n\"\"\"\n)\n</code></pre>"},{"location":"keywords/#bsse_type","title":"bsse_type","text":"<p>The <code>bsse_type</code> parameter specifies the type of correction for basis set superposition error (BSSE). Multiple types can be specified, in which case the results will include separate fields for each type of correction.</p> <p>Valid types are:</p> <ul> <li><code>nocp</code> - No counterpoise or other corrections applied</li> <li><code>cp</code> - Counterpoise correction</li> <li><code>vmfc</code> - Valiron-Mayer function counterpoise correction</li> </ul>"},{"location":"keywords/#levels-and-max_nbody","title":"levels and max_nbody","text":"<p>Dictionary of different levels of theory for different levels of expansion. The keys are integers or \"supersystem\", and the values are arbitrary strings that represent the model chemistry or level of theory to use for that level. This string is arbitrary and only has meaning to the user - the user is expected to map these strings to some meaningful definition of a calculation.</p> <p>If a <code>supersystem</code> key is present, all higher order n-body effects up to <code>max_nbody</code> will be computed.</p> <p>In the core interface, all levels must be accounted for (that is, keys must go from 1 to the maximum), and <code>max_nbody</code> cannot be specified. In the high-level interface, a computational model fills in for any lower unlisted n-body levels.</p> <p>In the high-level interface, if both levels and max_nbody are provided, they must be consistent. </p> <p>Examples:</p> <ul> <li><code>{2: 'ccsd(t)/cc-pvdz', 3: 'mp2'}</code></li> <li><code>max_nbody=3</code> and <code>levels={1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}</code></li> </ul>"},{"location":"keywords/#keywords-and-options_1","title":"Keywords and Options","text":""},{"location":"keywords/#return_total_data","title":"return_total_data","text":"<p>When set to true, the manybody calculation will return the total data (energy/gradient/hessian/property) of the system. If not, the return will only contain interaction data.</p> <p>Note that the calculation of counterpoise corrected total properties implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than. For some properties such as gradients and hessians, <code>return_total_data = False</code> is rarely useful.</p>"},{"location":"keywords/#supersystem_ie_only","title":"supersystem_ie_only","text":"<p>Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When false, each n-body level in the MBE up through <code>max_nbody</code> will be computed. When true (only allowed for <code>max_nbody = nfragments</code>), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body.</p> <p>When true, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code>; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers).</p> <p>This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code> Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings.</p>"},{"location":"qcschema/","title":"QCSchema","text":"<p>ManyBodyKeywords</p> key type required description default bsse_type False Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. [] embedding_charges typing.List[float] False Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. None return_total_data False When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of counterpoise corrected total energies implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than <code>return_total_data = False</code>. For gradients and Hessians, <code>return_total_data = False</code> is rarely useful. None levels False Dictionary of different levels of theory for different levels of expansion. Note that the primary method_string is not used when this keyword is given. <code>supersystem</code> computes all higher order n-body effects up to the number of fragments; this higher-order correction uses the nocp basis, regardless of bsse_type. A method fills in for any lower unlisted nbody levels. Note that if both this and max_nbody are provided, they must be consistent. Examples: SUPERSYSTEM definition suspect* {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} * Now invalid: {1: 2, 2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} None max_nbody False Maximum number of bodies to include in the many-body treatment. Possible: max_nbody &lt;= nfragments. Default: max_nbody = nfragments. None supersystem_ie_only False Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When False (default), compute each n-body level in the MBE up through <code>max_nbody</code>. When True (only allowed for <code>max_nbody = nfragments</code>), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body. When True, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code>; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers). This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code> Do not use with <code>vmfc</code> in <code>bsse_type</code>as it cannot produce savings. False <p>ManyBodySpecification</p> key type required description default schema_name typing.Literal['qcschema_manybodyspecification'] False qcschema_manybodyspecification keywords True The many-body-specific keywords for user control. None protocols False Protocols regarding the manipulation of a ManyBody output data. ManyBodyProtocols(component_results=) driver True The computation driver; i.e., energy, gradient, hessian. None specification True ??? TODO expand to cbs, fd None <p>ManyBodyInput</p> key type required description default schema_name typing.Literal['qcschema_manybodyinput'] False qcschema_manybodyinput specification True ??? None molecule True Target molecule for many-body expansion (MBE) or interaction energy (IE) analysis. None extras typing.Any False Additional information to bundle with the computation. Use for schema development and scratch space. {} <p>Note</p> <p>The properties model is generated dynamically based on a constant <code>MAX_NBODY</code>. To not overload the docs table, this is set to 5, which covers full calculations on tetramers. To use a larger <code>ManyBodyKeywords.max_nbody</code>, reset this value.</p> <pre><code>import qcmanybody as qcmb\nqcmb.models.MAX_NBODY = 8\n</code></pre> <p>ManyBodyResultProperties</p> key type required description default calcinfo_nmc False The number of model chemistries applied to n-body levels of the computation. None calcinfo_nfr False The number of fragments in the molecule for the computation. None calcinfo_natom False The number of atoms in the computation. None calcinfo_nmbe False The number of real/ghost molecule patterns for the computation. None nuclear_repulsion_energy False The nuclear repulsion energy. None return_energy False The interaction energy of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Always available. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.energy</code> computations. None return_gradient False The interaction gradient of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Available when driver is g/h. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.gradient</code> computations. None return_hessian False The interaction Hessian of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Available when driver is h. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.hessian</code> computations. None cp_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1. None cp_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2. None cp_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3. None cp_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4. None cp_corrected_total_energy False Best available total energy with cp treatment: cp_corrected_total_energy_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T. None cp_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy False Best available interaction energy with cp treatment: cp_corrected_interaction_energy_through_{max_nbody}_body. Available when cp in bsse_type. None cp_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2. None cp_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3. None cp_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4. None nocp_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1. None nocp_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2. None nocp_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3. None nocp_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4. None nocp_corrected_total_energy False Best available total energy without cp treatment: nocp_corrected_total_energy_through_{max_nbody}_body. Available when nocp in bsse_type. None nocp_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy False Best available interaction energy without cp treatment: nocp_corrected_interaction_energy_through_{max_nbody}_body. Available when nocp in bsse_type. None nocp_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2. None nocp_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3. None nocp_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4. None vmfc_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1. None vmfc_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2. None vmfc_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3. None vmfc_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4. None vmfc_corrected_total_energy False Best available total energy with vmfc treatment: vmfc_corrected_total_energy_through_{max_nbody}_body. Available when vmfc in bsse_type. None vmfc_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy False Best available interaction energy with vmfc treatment: vmfc_corrected_interaction_energy_through_{max_nbody}_body. Available when vmfc in bsse_type. None vmfc_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2. None vmfc_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3. None vmfc_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4. None cp_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1 &amp; driver is g/h. None cp_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2 &amp; driver is g/h. None cp_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3 &amp; driver is g/h. None cp_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4 &amp; driver is g/h. None cp_corrected_total_gradient False Best available total gradient with cp treatment: cp_corrected_total_gradient_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T &amp; driver is g/h. None cp_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient False Best available interaction gradient with cp treatment: cp_corrected_interaction_gradient_through_{max_nbody}_body. Available when cp in bsse_type &amp; driver is g/h. None cp_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None cp_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None cp_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None nocp_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. None nocp_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None nocp_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None nocp_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None nocp_corrected_total_gradient False Best available total gradient without cp treatment: nocp_corrected_total_gradient_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is g/h. None nocp_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient False Best available interaction gradient without cp treatment: nocp_corrected_interaction_gradient_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is g/h. None nocp_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None nocp_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None nocp_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None vmfc_corrected_total_gradient False Best available total gradient with vmfc treatment: vmfc_corrected_total_gradient_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is g/h. None vmfc_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient False Best available interaction gradient with vmfc treatment: vmfc_corrected_interaction_gradient_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is g/h. None vmfc_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None vmfc_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None vmfc_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None cp_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1 &amp; driver is h. None cp_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2 &amp; driver is h. None cp_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3 &amp; driver is h. None cp_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4 &amp; driver is h. None cp_corrected_total_hessian False Best available total Hessian with cp treatment: cp_corrected_total_hessian_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T &amp; driver is h. None cp_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian False Best available interaction Hessian with cp treatment: cp_corrected_interaction_hessian_through_{max_nbody}_body. Available when cp in bsse_type &amp; driver is h. None cp_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None cp_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None cp_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None nocp_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. None nocp_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None nocp_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None nocp_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None nocp_corrected_total_hessian False Best available total Hessian without cp treatment: nocp_corrected_total_hessian_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is h. None nocp_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian False Best available interaction Hessian without cp treatment: nocp_corrected_interaction_hessian_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is h. None nocp_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None nocp_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None nocp_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None vmfc_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. None vmfc_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None vmfc_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None vmfc_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None vmfc_corrected_total_hessian False Best available total Hessian with vmfc treatment: vmfc_corrected_total_hessian_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is h. None vmfc_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian False Best available interaction Hessian with vmfc treatment: vmfc_corrected_interaction_hessian_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is h. None vmfc_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None vmfc_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None vmfc_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None <p>ManyBodyResult</p> key type required description default input_data True None success typing.Literal[True] False Always <code>True</code> for a successful result True stdout False The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. None stderr False The standard error of the program execution. None schema_name typing.Literal['qcschema_manybodyresult'] False qcschema_manybodyresult schema_version typing.Literal[1] False The version number of <code>schema_name</code> to which this model conforms. 1 id False The optional ID for the object. None extras typing.Any False Additional information to bundle with the object. Use for schema development and scratch space. {} provenance True Provenance information. None properties True None None component_properties True The key results for each subsystem species computed. Keys contain modelchem, real and ghost information (e.g., <code>'[\"(auto)\", [2], [1, 2, 3]]'</code>). Values are total e/g/H/property results. Array values, if present, are sized and shaped for the full supersystem. None component_results False Detailed results {} return_result typing.Union[float, qcelemental.models.types.Array, typing.Dict[str, typing.Any]] True The primary return specified by the :attr:<code>~qcelemental.models.AtomicInput.driver</code> field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. None"},{"location":"qcschema/#qcmanybody.models.BsseEnum","title":"qcmanybody.models.BsseEnum","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Available basis-set superposition error (BSSE) treatments.</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyKeywords","title":"qcmanybody.models.ManyBodyKeywords","text":"<p>             Bases: <code>ProtoModel</code></p> <p>The many-body-specific keywords for user control.</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodySpecification","title":"qcmanybody.models.ManyBodySpecification","text":"<p>             Bases: <code>ProtoModel</code></p> <p>Combining the what (ManyBodyKeywords) with the how (AtomicSpecification).</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyInput","title":"qcmanybody.models.ManyBodyInput","text":"<p>             Bases: <code>ProtoModel</code></p> <p>Combining the what and how (ManyBodySpecification) with the who (Molecule).</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyResultProperties","title":"qcmanybody.models.ManyBodyResultProperties  <code>module-attribute</code>","text":"<pre><code>ManyBodyResultProperties = ProtoModelSkipDefaults\n</code></pre>"},{"location":"qcschema/#qcmanybody.models.ManyBodyResult","title":"qcmanybody.models.ManyBodyResult","text":"<p>             Bases: <code>SuccessfulResultBase</code></p>"},{"location":"results/","title":"Results","text":"<p>The QCManyBody package outputs many results from its analysis.</p> <p>For the core interface, the results are expected to be stored in a nested dictionary. For the high-level interface, the results are stored in a <code>ManyBodyResult</code> object.</p>"},{"location":"results/#fields","title":"Fields","text":""}]}