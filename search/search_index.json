{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QCManyBody Documentation","text":"<p>QCManyBody is a python package for running quantum chemistry many-body expansions and interaction calculations in a package-independent way.</p>"},{"location":"#installation","title":"Installation","text":"<p>QCManyBody is available from PyPI and from conda-forge.</p> <pre><code># Installation from PyPI\npip install qcmanybody\n\n# Installation from conda-forge\nconda install -c conda-forge qcmanybody\n</code></pre> <p>To install the latest development version directly from GitHub, you can use the following command:</p> <pre><code>pip install git+https://github.com/MolSSI/QCManyBody.git\n</code></pre>"},{"location":"#package-overview","title":"Package Overview","text":"<p>The package has two main interfaces. The high-level interface allows for a comprehensive workflow, where the user provides complete information about the calculation, including the full specification (method, basis set, etc.) of the many-body calculation. This is designed to work with QCEngine or other packages that implement the QCSchema.</p> <p>For more information, see High-level interface.</p> <p>QCManyBody also has a low-level core interface that allows for more flexibility in how the calculations are run. This interface generally takes a molecule and an arbitrary definition of quantum chemistry specifications, and expects the user to run them themselves.</p> <p>For more information, see Core interface.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Common Keywords and Options</li> <li>High-level Interface</li> <li>Core Interface</li> <li>Results</li> <li>How-To Guides</li> </ol>"},{"location":"api/","title":"API Documentation","text":"<p>ManyBodyComputer</p> key type required description default input_data True Input schema containing the relevant settings for performing the many body expansion. This is entirely redundant with the piecemeal assembly of this Computer class and is only stored to be available for error handling and exact reconstruction of ManyBodyResult. None bsse_type False Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. [] molecule True Target molecule for many body expansion (MBE) or interaction energy (IE) analysis. Fragmentation should already be defined in <code>fragments</code> and related fields. None driver True The computation driver; i.e., energy, gradient, hessian. In case of ambiguity (e.g., MBE gradient through finite difference energies or MBE energy through composite method), this field refers to the target derivative, not any means specification. None embedding_charges typing.List[float] False Atom-centered point charges to be used to speed up nbody-level convergence. Charges are placed on molecule fragments whose basis sets are not included in the computation. (An implication is that charges aren't invoked for bsse_type=cp.) Keys: 1-based index of fragment. Values: list of atom charges for that fragment. None return_total_data False When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of counterpoise corrected total energies implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than <code>return_total_data = False</code>. For gradients and Hessians, <code>return_total_data = False</code> is rarely useful. None levels False Dictionary of different levels of theory for different levels of expansion. Note that the primary method_string is not used when this keyword is given. <code>supersystem</code> computes all higher order n-body effects up to the number of fragments; this higher-order correction uses the nocp basis, regardless of bsse_type. A method fills in for any lower unlisted nbody levels. Note that if both this and max_nbody are provided, they must be consistent. Examples: SUPERSYSTEM definition suspect* {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} * Now invalid: {1: 2, 2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} Examples above are processed in the ManyBodyComputer, and once processed, only the values should be used. The keys turn into nbodies_per_mc_level, as notated below. * {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} -&gt; nbodies_per_mc_level=[[1], [2], ['supersystem']] * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} -&gt; nbodies_per_mc_level=[[1, 2], [3]] None max_nbody False Maximum number of bodies to include in the many-body treatment. Possible: max_nbody &lt;= nfragments. Default: max_nbody = nfragments. None supersystem_ie_only False Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When False (default), compute each n-body level in the MBE up through <code>max_nbody</code>. When True (only allowed for <code>max_nbody = nfragments</code> ), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body. When True, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code> ; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers). This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code>. Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings. False task_list typing.Any False {} qcmb_core typing.Any False Low-level interface None"},{"location":"api/#qcmanybody.ManyBodyCore","title":"qcmanybody.ManyBodyCore","text":"<pre><code>ManyBodyCore(molecule: Molecule, bsse_type: Sequence[BsseEnum], levels: Mapping[Union[int, Literal['supersystem']], str], *, return_total_data: bool, supersystem_ie_only: bool, embedding_charges: Mapping[int, Sequence[float]])\n</code></pre> Source code in <code>qcmanybody/core.py</code> <pre><code>def __init__(\n    self,\n    molecule: Molecule,\n    bsse_type: Sequence[BsseEnum],\n    levels: Mapping[Union[int, Literal[\"supersystem\"]], str],\n    *,\n    return_total_data: bool,\n    supersystem_ie_only: bool,\n    embedding_charges: Mapping[int, Sequence[float]],\n):\n    self.embedding_charges = embedding_charges\n    if self.embedding_charges:\n        if not bool(os.environ.get(\"QCMANYBODY_EMBEDDING_CHARGES\", False)):  # obscure until further validation\n            raise ValueError(\n                f\"Embedding charges for EE-MBE are still in testing. Set environment variable QCMANYBODY_EMBEDDING_CHARGES=1 to use at your own risk.\"\n            )\n\n    if isinstance(molecule, dict):\n        mol = Molecule(**molecule)\n    elif isinstance(molecule, Molecule):\n        mol = molecule.copy()\n    else:\n        raise ValueError(f\"Molecule input type of {type(molecule)} not understood.\")\n    self.molecule = mol\n    self.bsse_type = [BsseEnum(x) for x in bsse_type]\n    self.return_total_data = return_total_data\n    self.supersystem_ie_only = supersystem_ie_only\n    self.nfragments = len(self.molecule.fragments)\n\n    self.levels = levels\n\n    # Levels without supersystem\n    self.levels_no_ss = {int(k): v for k, v in levels.items() if k != \"supersystem\"}\n\n    # Just a set of all the modelchems\n    self.mc_levels = set(self.levels.values())\n\n    self.max_nbody = max(self.levels_no_ss.keys())\n\n    if len(self.bsse_type) == 0:\n        raise ValueError(\"No BSSE correction specified\")\n\n    if BsseEnum.vmfc in self.bsse_type and len(set(self.levels.values())) == 1:\n        # For single-modelchem VMFC, NOCP &amp; sometimes CP are produced for free\n        if BsseEnum.nocp not in self.bsse_type:\n            self.bsse_type.append(BsseEnum.nocp)\n        if BsseEnum.cp not in self.bsse_type and self.max_nbody == self.nfragments:\n            self.bsse_type.append(BsseEnum.cp)\n\n    self.return_bsse_type = self.bsse_type[0]\n\n    ###############################\n    # Build nbodies_per_mc_level\n    # TODO - use Lori's code\n    # TODO - dict to list of lists to handle non-contiguous levels\n    # TODO multilevel and supersystem_ie_only=T not allowed together\n    # TODO supersystem in levels is not to be trusted -- nfrag only and skips levels\n    max_level = max(self.levels_no_ss.keys())\n\n    if set(range(1, max_level + 1)) != set(self.levels_no_ss.keys()):\n        raise ValueError(f\"Levels must be contiguous from 1 to {max_level}\")\n\n    self.nbodies_per_mc_level: Dict[str, list] = {mc_level: [] for mc_level in self.mc_levels}\n    for k, v in self.levels_no_ss.items():\n        self.nbodies_per_mc_level[v].append(k)\n\n    # order nbodies_per_mc_level keys (modelchems) by the lowest n-body level covered; any\n    #   supersystem key (replaced below) is at the end. Order nbodies within each modelchem.\n    #   Reset mc_levels to match.\n    self.nbodies_per_mc_level = {\n        k: sorted(v)\n        for (k, v) in sorted(self.nbodies_per_mc_level.items(), key=lambda item: sorted(item[1] or [1000])[0])\n    }\n    assert self.mc_levels == set(self.nbodies_per_mc_level.keys())  # remove after some downstream testing\n    self.mc_levels = self.nbodies_per_mc_level.keys()\n\n    for mc, nbs in self.nbodies_per_mc_level.items():\n        if nbs and ((nbs[-1] - nbs[0]) != len(nbs) - 1):\n            raise ValueError(\n                f\"QCManyBody: N-Body levels must be contiguous within a model chemistry spec ({mc}: {nbs}). Use an alternate spec name to accomplish this input.\"\n            )\n            # TODO - test and reenable if appropriate. my guess is that noncontig nb is fine on the core computing side,\n            #   but trouble for computer and nbodies_per_mc_level inverting and indexing. Safer to deflect for now since input tweak allows the calc.\n\n    # Supersystem is always at the end\n    if \"supersystem\" in levels:\n        ss_mc = levels[\"supersystem\"]\n        self.nbodies_per_mc_level[ss_mc].append(\"supersystem\")\n\n    # To be built on the fly\n    self.mc_compute_dict = None\n\n    if self.nfragments == 1:\n        # Usually we try to \"pass-through\" edge cases, so a single-fragment mol would return 0 or ordinary energy,\n        #   depending on rtd=T/F. But it seems more likely that user just forgot the fragments field, so we don't\n        #   want to start a full energy on monsterMol. Reconsider handling in future.\n        raise ValueError(\"\"\"QCManyBody: Molecule fragmentation has not been specified through `fragments` field.\"\"\")\n\n    if not np.array_equal(np.concatenate(self.molecule.fragments), np.arange(len(self.molecule.symbols))):\n        raise ValueError(\"\"\"QCManyBody: non-contiguous fragments could be implemented but aren't at present\"\"\")\n\n    # Build size and slices dictionaries. Assumes fragments are contiguous\n    self.fragment_size_dict = {}\n    self.fragment_slice_dict = {}\n    iat = 0\n    for ifr in range(1, self.nfragments + 1):\n        nat = len(self.molecule.fragments[ifr - 1])\n        self.fragment_size_dict[ifr] = nat\n        self.fragment_slice_dict[ifr] = slice(iat, iat + nat)\n        iat += nat\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCore.format_calc_plan","title":"format_calc_plan","text":"<pre><code>format_calc_plan(sset: str = 'all') -&gt; Tuple[str, Dict[str, Dict[int, int]]]\n</code></pre> <p>Formulate per-modelchem and per-body job count data and summary text.</p> <p>Parameters:</p> Name Type Description Default <code>sset</code> <code>str</code> <p>Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.</p> <code>'all'</code> <p>Returns:</p> Type Description <code>info</code> <p>A text summary with per- model chemistry and per- n-body-level job counts. <pre><code>Model chemistry \"c4-ccsd\" (\u00a7A):         22\n     Number of 1-body computations:     16 (nocp: 0, cp: 0, vmfc_compute: 16)\n     Number of 2-body computations:      6 (nocp: 0, cp: 0, vmfc_compute: 6)\n\nModel chemistry \"c4-mp2\" (\u00a7B):          28\n     Number of 1-body computations:     12 (nocp: 0, cp: 0, vmfc_compute: 12)\n     Number of 2-body computations:     12 (nocp: 0, cp: 0, vmfc_compute: 12)\n     Number of 3-body computations:      4 (nocp: 0, cp: 0, vmfc_compute: 4)\n</code></pre></p> <code>Dict[str, Dict[int, int]]</code> <p>Data structure with outer key mc-label, inner key 1-indexed n-body, and value job count.</p> Source code in <code>qcmanybody/core.py</code> <pre><code>def format_calc_plan(self, sset: str = \"all\") -&gt; Tuple[str, Dict[str, Dict[int, int]]]:\n    \"\"\"Formulate per-modelchem and per-body job count data and summary text.\n\n    Parameters\n    ----------\n    sset\n        Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.\n\n    Returns\n    -------\n    info\n        A text summary with per- model chemistry and per- n-body-level job counts.\n        ```\n        Model chemistry \"c4-ccsd\" (\u00a7A):         22\n             Number of 1-body computations:     16 (nocp: 0, cp: 0, vmfc_compute: 16)\n             Number of 2-body computations:      6 (nocp: 0, cp: 0, vmfc_compute: 6)\n\n        Model chemistry \"c4-mp2\" (\u00a7B):          28\n             Number of 1-body computations:     12 (nocp: 0, cp: 0, vmfc_compute: 12)\n             Number of 2-body computations:     12 (nocp: 0, cp: 0, vmfc_compute: 12)\n             Number of 3-body computations:      4 (nocp: 0, cp: 0, vmfc_compute: 4)\n        ```\n    Dict[str, Dict[int, int]]\n        Data structure with outer key mc-label, inner key 1-indexed n-body, and value job count.\n    \"\"\"\n    # Rearrange compute_list from key nb having values (species) to compute all of that nb\n    #   to key nb having values counting that nb.\n    compute_list_count = {}\n    for mc, compute_dict in self.compute_map.items():\n        compute_list_count[mc] = {}\n        for sub in compute_dict:  # all, nocp, cp, vmfc\n            all_calcs = set().union(*compute_dict[sub].values())\n            compute_list_count[mc][sub] = Counter([len(frag) for (frag, _) in all_calcs])\n\n    mc_labels = modelchem_labels(self.nbodies_per_mc_level, presorted=True)\n    full_to_ordinal_mc_lbl = {v[0]: v[1] for v in mc_labels.values()}\n    info = []\n    for mc, counter in compute_list_count.items():\n        all_counter = counter[\"all\"]\n        mcheader = f'    Model chemistry \"{mc}\" ({full_to_ordinal_mc_lbl[mc]}):'\n        info.append(f\"{mcheader:38} {sum(all_counter.values()):6}\")\n        for nb, count in sorted(all_counter.items()):\n            other_counts = [f\"{sub}: {counter[sub][nb]}\" for sub in [\"nocp\", \"cp\", \"vmfc_compute\"]]\n            info.append(f\"        Number of {nb}-body computations: {count:6} ({', '.join(other_counts)})\")\n        info.append(\"\")\n    info = \"\\n\".join(info)\n\n    logger.info(info)\n    return info, {mc: dsset[sset] for mc, dsset in compute_list_count.items()}\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCore.iterate_molecules","title":"iterate_molecules","text":"<pre><code>iterate_molecules() -&gt; Iterable[Tuple[str, str, Molecule]]\n</code></pre> <p>Iterate over all the molecules needed for the computation.</p> <p>Yields model chemistry, label, and molecule.</p> Source code in <code>qcmanybody/core.py</code> <pre><code>def iterate_molecules(self) -&gt; Iterable[Tuple[str, str, Molecule]]:\n    \"\"\"Iterate over all the molecules needed for the computation.\n\n    Yields model chemistry, label, and molecule.\n    \"\"\"\n\n    done_molecules = set()\n\n    for mc, compute_dict in self.compute_map.items():\n        # TODO - this is a bit of a hack. Lots of duplication when reaching higher nbody\n        for compute_list in compute_dict[\"all\"].values():\n            for real_atoms, basis_atoms in compute_list:\n                label = labeler(mc, real_atoms, basis_atoms)\n                if label in done_molecules:\n                    continue\n\n                ghost_atoms = list(set(basis_atoms) - set(real_atoms))\n\n                # Shift to zero-indexing\n                real_atoms_0 = [x - 1 for x in real_atoms]\n                ghost_atoms_0 = [x - 1 for x in ghost_atoms]\n                mol = self.molecule.get_fragment(real_atoms_0, ghost_atoms_0, orient=False, group_fragments=False)\n                mol = mol.copy(update={\"fix_com\": True, \"fix_orientation\": True})\n\n                if self.embedding_charges:\n                    embedding_frags = list(set(range(1, self.nfragments + 1)) - set(basis_atoms))\n                    charges = []\n                    for ifr in embedding_frags:\n                        positions = self.molecule.get_fragment(ifr - 1).geometry.tolist()\n                        charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[ifr])])\n                    mol.extras[\"embedding_charges\"] = charges\n\n                done_molecules.add(label)\n                yield mc, label, mol\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCore.analyze","title":"analyze","text":"<pre><code>analyze(component_results: Dict[str, Dict[str, Union[float, ndarray]]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>component_results</code> <code>Dict[str, Dict[str, Union[float, ndarray]]]</code> <p>Nested dictionary with results from all individual molecular system calculations, including all subsystem/basis combinations, all model chemistries, and all properties (e.g., e/g/h).</p> <p>For example, the below is the format for a nocp gradient run on a helium dimer with 1-body at CCSD and 2-body at MP2. The outer string key can be generated with the <code>qcmanybody.utils.labeler</code> function. The inner string key is any property; QCManyBody presently knows how to process energy/gradient/Hessian. <pre><code>{'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])},\n}\n</code></pre></p> required Source code in <code>qcmanybody/core.py</code> <pre><code>def analyze(\n    self,\n    component_results: Dict[str, Dict[str, Union[float, np.ndarray]]],\n):\n    \"\"\"\n\n    Parameters\n    ----------\n    component_results\n        Nested dictionary with results from all individual molecular system\n        calculations, including all subsystem/basis combinations, all model\n        chemistries, and all properties (e.g., e/g/h).\n\n        For example, the below is the format for a nocp gradient run on a\n        helium dimer with 1-body at CCSD and 2-body at MP2. The outer string\n        key can be generated with the ``qcmanybody.utils.labeler`` function.\n        The inner string key is any property; QCManyBody presently knows how\n        to process energy/gradient/Hessian.\n        ```\n        {'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n         '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n         '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n         '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n         '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])},\n        }\n        ```\n    \"\"\"\n\n    # All properties that were passed to us\n    # * seed with \"energy\" so free/no-op jobs can process\n    available_properties: Set[str] = {\"energy\"}\n    for property_data in component_results.values():\n        available_properties.update(property_data.keys())\n\n    # reorganize to component_results_inv[property][label] = 1.23\n    component_results_inv = {k: {} for k in available_properties}\n\n    for cluster_label, property_data in component_results.items():\n        for property_label, property_value in property_data.items():\n            component_results_inv[property_label][cluster_label] = property_value\n\n    # Remove any missing data\n    component_results_inv = {k: v for k, v in component_results_inv.items() if v}\n    if not component_results_inv:\n        # Note B: Rarely, \"no results\" is expected, like for CP-only,\n        #   rtd=False, and max_nbody=1. We'll add a dummy entry so\n        #   processing can continue.\n        component_results_inv[\"energy\"] = {'[\"dummy\", [1000], [1000]]': 0.0}\n\n    # Actually analyze\n    is_embedded = bool(self.embedding_charges)\n    component_properties = defaultdict(dict)\n    all_results = {}\n    nbody_dict = {}\n    stdout = \"\"\n    #        all_results[\"energy_body_dict\"] = {\"cp\": {1: 0.0}}\n\n    for property_label, property_results in component_results_inv.items():\n        # Expand gradient and hessian\n        if property_label == \"gradient\":\n            property_results = {k: self.resize_gradient(v, delabeler(k)[2]) for k, v in property_results.items()}\n        if property_label == \"hessian\":\n            property_results = {k: self.resize_hessian(v, delabeler(k)[2]) for k, v in property_results.items()}\n\n        r = self._analyze(property_label, property_results)\n        for k, v in property_results.items():\n            component_properties[k][\"calcinfo_natom\"] = len(self.molecule.symbols)\n            component_properties[k][f\"return_{property_label}\"] = v\n        all_results.update(r)\n\n    for bt in self.bsse_type:\n        stdout += print_nbody_energy(\n            all_results[\"energy_body_dict\"][bt],\n            f\"{bt.formal()} ({bt.abbr()})\",\n            self.nfragments,\n            modelchem_labels(self.nbodies_per_mc_level, presorted=True),\n            is_embedded,\n            self.supersystem_ie_only,\n            self.max_nbody if self.has_supersystem else None,\n        )\n\n    for property_label in available_properties:\n        for bt in self.bsse_type:\n            nbody_dict.update(\n                collect_vars(\n                    bt,\n                    property_label,\n                    all_results[f\"{property_label}_body_dict\"][bt],\n                    self.max_nbody,\n                    is_embedded,\n                    self.supersystem_ie_only,\n                    self.has_supersystem,\n                )\n            )\n\n    all_results[\"results\"] = nbody_dict\n    all_results[\"component_properties\"] = component_properties\n\n    # Make dictionary with \"1cp\", \"2cp\", etc\n    ebd = all_results[\"energy_body_dict\"]\n    all_results[\"energy_body_dict\"] = {str(k) + bt: v for bt in ebd for k, v in ebd[bt].items()}\n    all_results[\"stdout\"] = stdout\n\n    return all_results\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer","title":"qcmanybody.ManyBodyComputer","text":"<p>               Bases: <code>BaseComputerQCNG</code></p>"},{"location":"api/#qcmanybody.ManyBodyComputer.from_manybodyinput","title":"from_manybodyinput  <code>classmethod</code>","text":"<pre><code>from_manybodyinput(input_model: ManyBodyInput, build_tasks: bool = True)\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@classmethod\ndef from_manybodyinput(cls, input_model: ManyBodyInput, build_tasks: bool = True):\n\n    computer_model = cls(\n        molecule=input_model.molecule,\n        driver=input_model.specification.driver,\n        # v2: **input_model.specification.keywords.model_dump(exclude_unset=True),\n        **input_model.specification.keywords.dict(exclude_unset=True),\n        input_data=input_model,  # storage, to reconstitute ManyBodyResult\n    )\n    nb_per_mc = computer_model.nbodies_per_mc_level\n\n    # print(\"\\n&lt;&lt;&lt;  (ZZ 1) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben  &gt;&gt;&gt;\")\n    # v2: pprint.pprint(computer_model.model_dump(), width=200)\n    # pprint.pprint(computer_model.dict(), width=200)\n    # print(f\"nbodies_per_mc_level={nb_per_mc}\")\n\n    comp_levels = {}\n    for mc_level_idx, mtd in enumerate(computer_model.levels.values()):\n        for lvl1 in nb_per_mc[mc_level_idx]:\n            key = \"supersystem\" if lvl1 == \"supersystem\" else int(lvl1)\n            comp_levels[key] = mtd\n\n    specifications = {}\n    for mtd, spec in computer_model.input_data.specification.specification.items():\n        spec = spec.dict()\n        specifications[mtd] = {}\n        specifications[mtd][\"program\"] = spec.pop(\"program\")\n        specifications[mtd][\"specification\"] = spec\n        specifications[mtd][\"specification\"][\n            \"driver\"\n        ] = computer_model.driver  # overrides atomic driver with mb driver\n        specifications[mtd][\"specification\"].pop(\"schema_name\", None)\n\n    computer_model.qcmb_core = ManyBodyCore(\n        computer_model.molecule,\n        computer_model.bsse_type,\n        comp_levels,\n        return_total_data=computer_model.return_total_data,\n        supersystem_ie_only=computer_model.supersystem_ie_only,\n        embedding_charges=computer_model.embedding_charges,\n    )\n\n    # check that core and computer storage are consistent in mc ordering and grouping and nbody levels\n    assert (\n        list(computer_model.qcmb_core.nbodies_per_mc_level.values()) == computer_model.nbodies_per_mc_level\n    ), f\"CORE {computer_model.qcmb_core.nbodies_per_mc_level.values()} != COMPUTER {computer_model.nbodies_per_mc_level}\"\n    assert list(computer_model.qcmb_core.nbodies_per_mc_level.keys()) == list(\n        computer_model.levels.values()\n    ), f\"CORE {computer_model.qcmb_core.nbodies_per_mc_level.keys()} != COMPUTER {computer_model.levels.values()}\"\n\n    if not build_tasks:\n        return computer_model\n\n    try:\n        import qcengine as qcng\n    except ModuleNotFoundError:\n        raise ModuleNotFoundError(\n            \"Python module qcengine not found. Solve by installing it: \"\n            \"`conda install qcengine -c conda-forge` or `pip install qcengine`\"\n        )\n\n    component_properties = {}\n    component_results = {}\n\n    for chem, label, imol in computer_model.qcmb_core.iterate_molecules():\n        inp = AtomicInput(molecule=imol, **specifications[chem][\"specification\"])\n        # inp = AtomicInput(molecule=imol, **specifications[chem][\"specification\"], extras={\"psiapi\": True})  # faster for p4\n\n        if imol.extras.get(\"embedding_charges\"):  # or test on self.embedding_charges ?\n            if specifications[chem][\"program\"] == \"psi4\":\n                charges = imol.extras[\"embedding_charges\"]\n                fkw = inp.keywords.get(\"function_kwargs\", {})\n                fkw.update({\"external_potentials\": charges})\n                inp.keywords[\"function_kwargs\"] = fkw\n            else:\n                raise RuntimeError(\n                    f\"Don't know how to handle external charges in {specifications[chem]['program']}\"\n                )\n\n        _, real, bas = delabeler(label)\n        result = qcng.compute(inp, specifications[chem][\"program\"])\n        component_results[label] = result\n\n        if not result.success:\n            # print(result.error.error_message)\n            raise RuntimeError(\"Calculation did not succeed! Error:\\n\" + result.error.error_message)\n\n        # pull out stuff\n        props = {\"energy\", \"gradient\", \"hessian\"}\n\n        component_properties[label] = {}\n\n        for p in props:\n            if hasattr(result.properties, f\"return_{p}\"):\n                v = getattr(result.properties, f\"return_{p}\")\n                # print(f\"  {label} {p}: {v}\")\n                if v is not None:\n                    component_properties[label][p] = v\n\n    # print(\"\\n&lt;&lt;&lt;  (ZZ 2) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben component_properties  &gt;&gt;&gt;\")\n    # with np.printoptions(precision=6, suppress=True):\n    #     pprint.pprint(component_properties, width=200)\n\n    analyze_back = computer_model.qcmb_core.analyze(component_properties)\n    analyze_back[\"nbody_number\"] = len(component_properties)\n    # print(\"\\n&lt;&lt;&lt;  (ZZ 3) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben analyze_back  &gt;&gt;&gt;\")\n    # pprint.pprint(analyze_back, width=200)\n\n    return computer_model.get_results(external_results=analyze_back, component_results=component_results)\n</code></pre>"},{"location":"api/#qcmanybody.utils","title":"qcmanybody.utils","text":""},{"location":"api/#qcmanybody.utils.all_same_shape","title":"all_same_shape","text":"<pre><code>all_same_shape(it: Iterable[Union[float, ndarray]]) -&gt; bool\n</code></pre> <p>Check if all elements of an iterable have the same shape.</p> Source code in <code>qcmanybody/utils.py</code> <pre><code>def all_same_shape(it: Iterable[Union[float, np.ndarray]]) -&gt; bool:\n    \"\"\"Check if all elements of an iterable have the same shape.\"\"\"\n\n    it = iter(it)\n    try:\n        first = next(it)\n    except StopIteration:\n        return True\n    if isinstance(first, float):\n        return all(isinstance(x, float) for x in it)\n    elif isinstance(first, np.ndarray):\n        return all(x.shape == first.shape for x in it)\n    else:\n        raise TypeError(f\"Expected float or np.ndarray, got {type(first)}\")\n</code></pre>"},{"location":"api/#qcmanybody.utils.resize_gradient","title":"resize_gradient","text":"<pre><code>resize_gradient(grad: ndarray, bas: Tuple[int, ...], fragment_size_dict: Dict[int, int], fragment_slice_dict: Dict[int, slice], *, reverse: bool = False) -&gt; ndarray\n</code></pre> <p>Pads or extracts a gradient array between subsystem and full supersystem sizes.</p> <p>Parameters:</p> Name Type Description Default <code>grad</code> <code>ndarray</code> <p>Gradient matrix of natural size for bas, (3 * &lt;nat in bas&gt;, 3). If <code>reverse=True</code>, gradient matrix of supersystem size, (3 * &lt;nat of all fragments&gt;, 3).</p> required <code>bas</code> <code>Tuple[int, ...]</code> <p>1-indexed fragments active in grad. If <code>reverse=True</code>, 1-indexed fragments to be extracted from grad.</p> required <code>fragment_size_dict</code> <code>Dict[int, int]</code> <p>Dictionary containing the number of atoms of each 1-indexed fragment. For He--HOOH--Me cluster, <code>{1: 1, 2: 4, 3: 5}</code>.</p> required <code>fragment_slice_dict</code> <code>Dict[int, slice]</code> <p>Dictionary containing slices that index the gradient matrix for each of the 1-indexed fragments. For He--HOOH--Me cluster, <code>{1: slice(0, 1), 2: slice(1, 5), 3: slice(5, 10)}</code>.</p> required <code>reverse</code> <code>bool</code> <p>If True, contract grad from supersystem size and shape to that which is natural for bas.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Gradient array padded with zeros to supersystem size, (3 * &lt;nat of supersystem&gt;, 3). If reverse=True, gradient array extracted to natural size, (3 * &lt;nat in bas&gt;, 3).</p> Source code in <code>qcmanybody/utils.py</code> <pre><code>def resize_gradient(\n    grad: np.ndarray,\n    bas: Tuple[int, ...],\n    fragment_size_dict: Dict[int, int],\n    fragment_slice_dict: Dict[int, slice],\n    *,\n    reverse: bool = False,\n) -&gt; np.ndarray:\n    r\"\"\"Pads or extracts a gradient array between subsystem and full supersystem sizes.\n\n    Parameters\n    ----------\n    grad\n        Gradient matrix of natural size for *bas*, (3 * _&lt;nat in bas\\&gt;_, 3).\n        If `reverse=True`, gradient matrix of supersystem size, (3 * _&lt;nat of all fragments\\&gt;_, 3).\n    bas\n        1-indexed fragments active in *grad*.\n        If `reverse=True`, 1-indexed fragments to be extracted from *grad*.\n    fragment_size_dict\n        Dictionary containing the number of atoms of each 1-indexed fragment.\n        For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.\n    fragment_slice_dict\n        Dictionary containing slices that index the gradient matrix for each of the 1-indexed fragments.\n        For He--HOOH--Me cluster, `{1: slice(0, 1), 2: slice(1, 5), 3: slice(5, 10)}`.\n    reverse\n        If True, contract *grad* from supersystem size and shape to that which is natural for *bas*.\n\n    Returns\n    -------\n    np.ndarray\n        Gradient array padded with zeros to supersystem size, (3 * _&lt;nat of supersystem\\&gt;_, 3).\n        If reverse=True, gradient array extracted to natural size, (3 * _&lt;nat in bas\\&gt;_, 3).\n\n    \"\"\"\n    if reverse:\n        nat = sum(fragment_size_dict[ifr] for ifr in bas)\n    else:\n        nat = sum(fragment_size_dict.values())\n    ret = np.zeros((nat, 3))\n\n    start = 0\n    for ifr in bas:\n        end = start + fragment_size_dict[ifr]\n        if reverse:\n            ret[start:end] = grad[fragment_slice_dict[ifr]]\n        else:\n            ret[fragment_slice_dict[ifr]] = grad[start:end]\n        start += fragment_size_dict[ifr]\n\n    return ret\n</code></pre>"},{"location":"api/#qcmanybody.utils.resize_hessian","title":"resize_hessian","text":"<pre><code>resize_hessian(hess: ndarray, bas: Tuple[int, ...], fragment_size_dict: Dict[int, int], fragment_slice_dict: Dict[int, slice], *, reverse: bool = False) -&gt; ndarray\n</code></pre> <p>Pads or extracts a Hessian array between subsystem and full supersystem sizes.</p> <p>Parameters:</p> Name Type Description Default <code>hess</code> <code>ndarray</code> <p>Hessian matrix of natural size for bas, (3 * &lt;nat in bas&gt;, 3 * &lt;nat in bas&gt;). If <code>reverse=True</code>, Hessian matrix of supersystem size, (3 * &lt;nat of all fragments&gt;, 3 * &lt;nat of all fragments&gt;).</p> required <code>bas</code> <code>Tuple[int, ...]</code> <p>1-indexed fragments active in hess. If <code>reverse=True</code>, 1-indexed fragments to be extracted from hess.</p> required <code>fragment_size_dict</code> <code>Dict[int, int]</code> <p>Dictionary containing the number of atoms of each 1-indexed fragment. For He--HOOH--Me cluster, <code>{1: 1, 2: 4, 3: 5}</code>.</p> required <code>fragment_slice_dict</code> <code>Dict[int, slice]</code> <p>Dictionary containing slices that index the gradient matrix for each of the 1-indexed fragments. For He--HOOH--Me cluster, <code>{1: slice(0, 1), 2: slice(1, 5), 3: slice(5, 10)}</code>.</p> required <code>reverse</code> <code>bool</code> <p>If True, contract hess from supersystem size and shape to that which is natural for bas.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Hessian array padded with zeros to supersystem size, (3 * &lt;nat of supersystem&gt;, 3 * &lt;nat of supersystem&gt;). If reverse=True, Hessian array extracted to natural size, (3 * &lt;nat in bas&gt;, 3 * &lt;nat in bas&gt;).</p> Source code in <code>qcmanybody/utils.py</code> <pre><code>def resize_hessian(\n    hess: np.ndarray,\n    bas: Tuple[int, ...],\n    fragment_size_dict: Dict[int, int],\n    fragment_slice_dict: Dict[int, slice],\n    *,\n    reverse: bool = False,\n) -&gt; np.ndarray:\n    r\"\"\"Pads or extracts a Hessian array between subsystem and full supersystem sizes.\n\n    Parameters\n    ----------\n    hess\n        Hessian matrix of natural size for *bas*, (3 * _&lt;nat in bas\\&gt;_, 3 * _&lt;nat in bas\\&gt;_).\n        If `reverse=True`, Hessian matrix of supersystem size, (3 * _&lt;nat of all fragments\\&gt;_,\n        3 * _&lt;nat of all fragments\\&gt;_).\n    bas\n        1-indexed fragments active in *hess*.\n        If `reverse=True`, 1-indexed fragments to be extracted from *hess*.\n    fragment_size_dict\n        Dictionary containing the number of atoms of each 1-indexed fragment.\n        For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.\n    fragment_slice_dict\n        Dictionary containing slices that index the gradient matrix for each of the 1-indexed fragments.\n        For He--HOOH--Me cluster, `{1: slice(0, 1), 2: slice(1, 5), 3: slice(5, 10)}`.\n    reverse\n        If True, contract *hess* from supersystem size and shape to that which is natural for *bas*.\n\n    Returns\n    -------\n    ndarray\n        Hessian array padded with zeros to supersystem size, (3 * _&lt;nat of supersystem\\&gt;_,\n        3 * _&lt;nat of supersystem\\&gt;_). If reverse=True, Hessian array extracted to natural size,\n        (3 * _&lt;nat in bas\\&gt;_, 3 * _&lt;nat in bas\\&gt;_).\n\n    \"\"\"\n    if reverse:\n        nat = sum(fragment_size_dict[ifr] for ifr in bas)\n    else:\n        nat = sum(fragment_size_dict.values())\n    ret = np.zeros((nat * 3, nat * 3))\n\n    # Build up start and end slices\n    abs_start, rel_start = 0, 0\n    abs_slices, rel_slices = [], []\n    for ifr in bas:\n        rel_end = rel_start + 3 * fragment_size_dict[ifr]\n        rel_slices.append(slice(rel_start, rel_end))\n        rel_start += 3 * fragment_size_dict[ifr]\n\n        tmp_slice = fragment_slice_dict[ifr]\n        abs_slices.append(slice(tmp_slice.start * 3, tmp_slice.stop * 3))\n\n    for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):\n        for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):\n            if reverse:\n                ret[rel_sl1, rel_sl2] = hess[abs_sl1, abs_sl2]\n            else:\n                ret[abs_sl1, abs_sl2] = hess[rel_sl1, rel_sl2]\n\n    return ret\n</code></pre>"},{"location":"api/#qcmanybody.utils.sum_cluster_data","title":"sum_cluster_data","text":"<pre><code>sum_cluster_data(data: Dict[str, Union[float, ndarray]], compute_list: Set[FragBasIndex], mc_level_lbl: str, vmfc: bool = False, nb: int = 0) -&gt; Union[float, ndarray]\n</code></pre> <p>Sum (direct or alternate weight by n-body) like data from</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Union[float, ndarray]]</code> <p>Dictionary containing computed property (e/g/H/etc.) for each subsystem/component computation.</p> required <code>compute_list</code> <code>Set[FragBasIndex]</code> <p>A list of (frag, bas) tuples notating all the required computations for the desired sum.</p> required <code>mc_level_lbl</code> <code>str</code> <p>User label for what modelchem level results should be pulled out of data.</p> required <code>vmfc</code> <code>bool</code> <p>Is this a vmfc calculation, by default False?</p> <code>False</code> <code>nb</code> <code>int</code> <p>1-indexed n-body level only used when <code>vmfc=True</code>, by default 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Scalar or array containing summed energy, gradient, Hessian, or other result. Usually (nocp or cp; <code>vmfc=False</code>), compute_list defines all fragments of a given number of active fragments and active basis fragments, so the return is the 3b@3b sum, for example. Other times (<code>vmfc=True</code>), compute list defines all fragments of a given number of active basis fragments. Then alternating weighting is applied so if <code>nb=3</code>, the return is the quantity (3b@3b sum - 2b@3b sum + 1b@3b sum), for example.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shapes of all the <code>data</code> values aren't the same. No summing energies with gradients.</p> Source code in <code>qcmanybody/utils.py</code> <pre><code>def sum_cluster_data(\n    data: Dict[str, Union[float, np.ndarray]],\n    compute_list: Set[FragBasIndex],\n    mc_level_lbl: str,\n    vmfc: bool = False,\n    nb: int = 0,\n) -&gt; Union[float, np.ndarray]:\n    \"\"\"Sum (direct or alternate weight by n-body) like data from\n\n    Parameters\n    ----------\n    data\n        Dictionary containing computed property (e/g/H/etc.) for each subsystem/component computation.\n    compute_list\n        A list of (frag, bas) tuples notating all the required computations for the desired sum.\n    mc_level_lbl\n        User label for what modelchem level results should be pulled out of *data*.\n    vmfc\n        Is this a vmfc calculation, by default False?\n    nb\n        1-indexed n-body level only used when `vmfc=True`, by default 0.\n\n    Returns\n    -------\n    Union[float, np.ndarray]\n        Scalar or array containing summed energy, gradient, Hessian, or other result.\n        Usually (nocp or cp; `vmfc=False`), compute_list defines all fragments of a given number of\n        active fragments and active basis fragments, so the return is the 3b@3b sum, for example.\n        Other times (`vmfc=True`), compute list defines all fragments of a given number of active basis\n        fragments. Then alternating weighting is applied so if `nb=3`, the return is the quantity\n        (3b@3b sum - 2b@3b sum + 1b@3b sum), for example.\n\n    Raises\n    ------\n    ValueError\n        If the shapes of all the `data` values aren't the same. No summing energies with gradients.\n    \"\"\"\n    sign = 1\n\n    if not all_same_shape(data.values()):\n        raise ValueError(\"All values in data dictionary must have the same shape.\")\n\n    first_key = next(iter(data))\n    shape = find_shape(data[first_key])\n    ret = shaped_zero(shape)\n\n    precise_sum_func = math.fsum if isinstance(ret, float) else np.sum\n    ret = precise_sum_func(\n        (((-1) ** (nb - len(frag))) if vmfc else 1) * (data[labeler(mc_level_lbl, frag, bas)])\n        for frag, bas in compute_list\n    )\n\n    # A more readable format for the above but not ammenable to using specialty summation functions\n    # ```\n    # for frag, bas in compute_list:\n    #     egh = data[labeler(mc_level_lbl, frag, bas)]\n    #\n    #     if vmfc:\n    #         sign = (-1) ** (nb - len(frag))\n    #\n    #     ret += sign * egh\n    # ```\n\n    return ret\n</code></pre>"},{"location":"api/#qcmanybody.utils.labeler","title":"labeler","text":"<pre><code>labeler(mc_level_lbl: Optional[Union[str, int]], frag: Tuple[int, ...], bas: Tuple[int, ...], *, opaque: bool = True) -&gt; str\n</code></pre> <p>Form label from model chemistry id and fragment and basis indices.</p> <p>Parameters:</p> Name Type Description Default <code>mc_level_lbl</code> <code>Optional[Union[str, int]]</code> <p>Key identifying the model chemistry. May be <code>\"(auto)\"</code>. Often the ManyBodyInput.specification.specification keys. When <code>opaque=False</code>, result is for pretty printing so instead of a string, <code>mc_level_lbl</code> might be an integer index (apply 1-indexing beforehand) or None (if the model chemistry part is unwanted because single-level).</p> required <code>frag</code> <code>Tuple[int, ...]</code> <p>List of 1-indexed fragments active in the supersystem.</p> required <code>bas</code> <code>Tuple[int, ...]</code> <p>List of 1-indexed fragments with active basis sets in the supersystem. All those in frag plus any ghost.</p> required <code>opaque</code> <code>bool</code> <p>Toggle whether to return JSON-friendly semi-opaque internal str label (True) or eye-friendly label with @ for basis and \u00a7 for model chemistry (False).</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>JSON string from inputs:</p> <pre><code>labeler(\"mp2\", 1, (1, 2))\n#&gt; '[\"mp2\", [1], [1, 2]]'\nlabeler(\"mp2\", 1, (1, 2), opaque=False)\n#&gt; '\u00a7mp2_(1)@(1, 2)'\n</code></pre> Source code in <code>qcmanybody/utils.py</code> <pre><code>def labeler(\n    mc_level_lbl: Optional[Union[str, int]], frag: Tuple[int, ...], bas: Tuple[int, ...], *, opaque: bool = True\n) -&gt; str:\n    \"\"\"Form label from model chemistry id and fragment and basis indices.\n\n    Parameters\n    ----------\n    mc_level_lbl\n        Key identifying the model chemistry. May be `\"(auto)\"`. Often the\n        ManyBodyInput.specification.specification keys.\n        When `opaque=False`, result is for pretty printing so instead of a string,\n        `mc_level_lbl` might be an integer index (apply 1-indexing beforehand)\n        or None (if the model chemistry part is unwanted because single-level).\n    frag\n        List of 1-indexed fragments active in the supersystem.\n    bas\n        List of 1-indexed fragments with active basis sets in the supersystem.\n        All those in *frag* plus any ghost.\n    opaque\n        Toggle whether to return JSON-friendly semi-opaque internal str label (True) or\n        eye-friendly label with @ for basis and \u00a7 for model chemistry (False).\n\n    Returns\n    -------\n    str\n        JSON string from inputs:\n\n        ```python\n        labeler(\"mp2\", 1, (1, 2))\n        #&gt; '[\"mp2\", [1], [1, 2]]'\n        labeler(\"mp2\", 1, (1, 2), opaque=False)\n        #&gt; '\u00a7mp2_(1)@(1, 2)'\n        ```\n    \"\"\"\n    if isinstance(frag, int):\n        frag = (frag,)\n    if isinstance(bas, int):\n        bas = (bas,)\n\n    if opaque:\n        return json.dumps([str(mc_level_lbl), frag, bas])\n    else:\n        mc_pre = \"\" if mc_level_lbl is None else f\"\u00a7{mc_level_lbl}_\"\n        return f\"{mc_pre}({', '.join(map(str, frag))})@({', '.join(map(str, bas))})\"\n</code></pre>"},{"location":"api/#qcmanybody.utils.delabeler","title":"delabeler","text":"<pre><code>delabeler(item: str) -&gt; Tuple[str, Tuple[int, ...], Tuple[int, ...]]\n</code></pre> <p>Back-form from label into tuple.</p> <p>Returns:</p> Type Description <code>mcfragbas</code> <p>Tuple of opaque or pretty-print model chemistry (may be None for latter), fragments and bases (1-indexed by convention).</p> <pre><code>delabeler('[\"mp2\", [1], [1, 2]]')\n#&gt; ('mp2', [1], [1, 2])\ndelabeler(\"\u00a7mp2_(1)@(1, 2)\")\n#&gt; ('mp2', [1], [1, 2])\n</code></pre> Source code in <code>qcmanybody/utils.py</code> <pre><code>def delabeler(item: str) -&gt; Tuple[str, Tuple[int, ...], Tuple[int, ...]]:\n    \"\"\"Back-form from label into tuple.\n\n    Returns\n    -------\n    mcfragbas\n        Tuple of opaque or pretty-print model chemistry (may be None for latter),\n        fragments and bases (1-indexed by convention).\n\n        ```python\n        delabeler('[\"mp2\", [1], [1, 2]]')\n        #&gt; ('mp2', [1], [1, 2])\n        delabeler(\"\u00a7mp2_(1)@(1, 2)\")\n        #&gt; ('mp2', [1], [1, 2])\n        ```\n    \"\"\"\n\n    if \"@\" not in item:\n        mc, frag, bas = json.loads(item)\n        return str(mc), frag, bas\n    else:\n        mobj = re.match(r\"(?:\u00a7(?P&lt;mc&gt;\\S*)_)?(?P&lt;frag&gt;.*)@(?P&lt;bas&gt;.*)\", item)\n        mc, frag, bas = mobj.groups()\n        # want lists and avoids (1) non-iterable error\n        frag = frag.replace(\"(\", \"[\").replace(\")\", \"]\")\n        bas = bas.replace(\"(\", \"[\").replace(\")\", \"]\")\n        return mc, ast.literal_eval(frag), ast.literal_eval(bas)\n</code></pre>"},{"location":"api/#qcmanybody.utils.print_nbody_energy","title":"print_nbody_energy","text":"<pre><code>print_nbody_energy(energy_body_dict: Mapping[int, float], header: str, nfragments: int, modelchem_labels, embedding: bool, supersystem_ie_only: bool, supersystem_beyond: Optional[int]) -&gt; str\n</code></pre> <p>Format summary string for energies of a single bsse_type. Logs and returns output.</p> <p>Parameters:</p> Name Type Description Default <code>energy_body_dict</code> <code>Mapping[int, float]</code> <p>Input data.</p> required <code>header</code> <code>str</code> <p>Specialization for table title.</p> required <code>nfragments</code> <code>int</code> <p>Number of lines in table is number of fragments.</p> required <code>modelchem_labels</code> <p>Dictionary mapping active nbody-levels to a tuple with first element the full model chemistry key and second element a short label. A suitable dictionary is <code>modelchem_labels(manybodycore_instance.nbodies_per_mc_level)</code>.</p> required <code>embedding</code> <code>bool</code> <p>Whether charge embedding present suppress printing, usually False</p> required <code>supersystem_ie_only</code> <code>bool</code> <p>Whether only 1-body and nfragments-body levels are available, usually False.</p> required <code>supersystem_beyond</code> <code>Optional[int]</code> <p>If not None, the number of nbody-levels computed by MBE explicitly. Beyond this gets supersystem SS label.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A text table in Hartrees and kcal/mol</p> <pre><code>==&gt; N-Body: Counterpoise Corrected (CP) energies &lt;=='\n\n        n-Body     Total Energy            Interaction Energy                          N-body Contribution to Interaction Energy'\n                   [Eh]                    [Eh]                  [kcal/mol]            [Eh]                  [kcal/mol]'\n             1     -386.455609352609        0.000000000000        0.000000000000        0.000000000000        0.000000000000'\n             2     -384.203153844163        2.252455508446     1413.437170812134        2.252455508446     1413.437170812134'\n  FULL/RTN   3     -384.128628718676        2.326980633933     1460.202393089624        0.074525125487       46.765222277490'\n</code></pre> Source code in <code>qcmanybody/utils.py</code> <pre><code>def print_nbody_energy(\n    energy_body_dict: Mapping[int, float],\n    header: str,\n    nfragments: int,\n    modelchem_labels,\n    embedding: bool,\n    supersystem_ie_only: bool,\n    supersystem_beyond: Optional[int],\n) -&gt; str:\n    \"\"\"Format summary string for energies of a single bsse_type. Logs and returns output.\n\n    Parameters\n    ----------\n    energy_body_dict\n        Input data.\n    header\n        Specialization for table title.\n    nfragments\n        Number of lines in table is number of fragments.\n    modelchem_labels\n        Dictionary mapping active nbody-levels to a tuple with first element the\n        full model chemistry key and second element a short label. A suitable\n        dictionary is `modelchem_labels(manybodycore_instance.nbodies_per_mc_level)`.\n    embedding\n        Whether charge embedding present suppress printing, usually False\n    supersystem_ie_only\n        Whether only 1-body and nfragments-body levels are available, usually False.\n    supersystem_beyond\n        If not None, the number of nbody-levels computed by MBE explicitly. Beyond this gets supersystem SS label.\n\n    Returns\n    -------\n    str\n        A text table in Hartrees and kcal/mol\n\n        ```\n        ==&gt; N-Body: Counterpoise Corrected (CP) energies &lt;=='\n\n                n-Body     Total Energy            Interaction Energy                          N-body Contribution to Interaction Energy'\n                           [Eh]                    [Eh]                  [kcal/mol]            [Eh]                  [kcal/mol]'\n                     1     -386.455609352609        0.000000000000        0.000000000000        0.000000000000        0.000000000000'\n                     2     -384.203153844163        2.252455508446     1413.437170812134        2.252455508446     1413.437170812134'\n          FULL/RTN   3     -384.128628718676        2.326980633933     1460.202393089624        0.074525125487       46.765222277490'\n        ```\n    \"\"\"\n    info = f\"\"\"\\n   ==&gt; N-Body: {header} energies &lt;==\\n\\n\"\"\"\n    info += f\"\"\"        {\"MC n-Body\":&gt;15}  Total Energy            Interaction Energy                          N-body Contribution to Interaction Energy\\n\"\"\"\n    info += f\"\"\"                         [Eh]                    [Eh]                  [kcal/mol]            [Eh]                  [kcal/mol]\\n\"\"\"\n    previous_e = energy_body_dict[1]\n    tot_e = previous_e != 0.0\n    nbody_range = list(energy_body_dict)\n    if supersystem_ie_only:\n        nbody_range = [1, nfragments]\n    nbody_range.sort()\n    for nb in range(1, nfragments + 1):\n        lbl = []\n        if supersystem_beyond and nb &gt; supersystem_beyond:\n            lbl.append(\"SS\")\n        if nb == nfragments:\n            lbl.append(\"FULL\")\n        if nb == max(nbody_range):\n            lbl.append(\"RTN\")\n        lbl = \"/\".join(lbl)\n\n        mclbl = modelchem_labels.get(nb, (\"\", \"\"))[1]\n\n        if nb in nbody_range:\n            delta_e = energy_body_dict[nb] - previous_e\n            delta_e_kcal = delta_e * constants.hartree2kcalmol\n            if embedding:\n                int_e = np.nan\n                int_e_kcal = np.nan\n            else:\n                int_e = energy_body_dict[nb] - energy_body_dict[1]\n                int_e_kcal = int_e * constants.hartree2kcalmol\n            if supersystem_ie_only and nb == nfragments:\n                if tot_e:\n                    info += f\"\"\"  {lbl:&gt;11} {mclbl:2} {nb:2}  {energy_body_dict[nb]:20.12f}  {int_e:20.12f}  {int_e_kcal:20.12f}        {\"N/A\":20}  {\"N/A\":20}\\n\"\"\"\n                else:\n                    info += f\"\"\"  {lbl:&gt;11} {mclbl:2} {nb:2}        {\"N/A\":14}  {int_e:20.12f}  {int_e_kcal:20.12f}        {\"N/A\":20}  {\"N/A\":20}\\n\"\"\"\n            else:\n                if tot_e:\n                    if embedding:\n                        info += f\"\"\"  {lbl:&gt;11} {mclbl:2} {nb:2}  {energy_body_dict[nb]:20.12f}        {\"N/A\":20}  {\"N/A\":14}  {delta_e:20.12f}  {delta_e_kcal:20.12f}\\n\"\"\"\n                    else:\n                        info += f\"\"\"  {lbl:&gt;11} {mclbl:2} {nb:2}  {energy_body_dict[nb]:20.12f}  {int_e:20.12f}  {int_e_kcal:20.12f}  {delta_e:20.12f}  {delta_e_kcal:20.12f}\\n\"\"\"\n                else:\n                    info += f\"\"\"  {lbl:&gt;11} {mclbl:2} {nb:2}        {\"N/A\":14}  {int_e:20.12f}  {int_e_kcal:20.12f}  {delta_e:20.12f}  {delta_e_kcal:20.12f}\\n\"\"\"\n            previous_e = energy_body_dict[nb]\n        else:\n            info += f\"\"\"  {lbl:&gt;11} {\"\":2} {nb:2}        {\"N/A\":20}  {\"N/A\":20}  {\"N/A\":20}  {\"N/A\":20}  {\"N/A\":20}\\n\"\"\"\n\n    mc_legend = {tup[1]: tup[0] for tup in modelchem_labels.values()}\n    mc_legend = [f'{k}: \"{v}\"' for k, v in mc_legend.items()]\n    info += f\"\\n   MC Legend: {', '.join(mc_legend)}\\n\\n\"\n    return info\n</code></pre>"},{"location":"api/#qcmanybody.utils.collect_vars","title":"collect_vars","text":"<pre><code>collect_vars(bsse: str, prop: str, body_dict: Mapping[int, Union[float, ndarray]], max_nbody: int, embedding: bool = False, supersystem_ie_only: bool = False, has_supersystem: bool = False) -&gt; Dict\n</code></pre> <p>From body_dict, construct data for ManyBodyResultProperties.</p> <p>Parameters:</p> Name Type Description Default <code>bsse</code> <code>str</code> <p>Label for a single many-body treatment, generally a value of BsseEnum.</p> required <code>prop</code> <code>str</code> <p>Label for a single property, generally a value of DriverEnum.</p> required <code>body_dict</code> <code>Mapping[int, Union[float, ndarray]]</code> <p>Dictionary of minimal per-body info already specialized for property prop and treatment bsse. May contain either total data or interaction data (cummulative, not additive) from 1-body to max_nbody-body (see also supersystem_ie_only). Interaction data signaled by zero float or array for 1-body. May contain data from multiple model chemistry levels.</p> required <code>max_nbody</code> <code>int</code> <p>description</p> required <code>embedding</code> <code>bool</code> <p>Is charge embedding enabled, by default False?</p> <code>False</code> <code>supersystem_ie_only</code> <code>bool</code> <p>Is data available in body_dict only for 1-body (possibly zero) and nfr-body levels? By default False: data is available for consecutive levels, up to max_nbody-body.</p> <code>False</code> <code>has_supersystem</code> <code>bool</code> <p>Whether contributions higher than max_nbody are a summary correction.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>description. Empty return if embedding enabled.</p> Source code in <code>qcmanybody/utils.py</code> <pre><code>def collect_vars(\n    bsse: str,\n    prop: str,\n    body_dict: Mapping[int, Union[float, np.ndarray]],\n    max_nbody: int,\n    embedding: bool = False,\n    supersystem_ie_only: bool = False,\n    has_supersystem: bool = False,\n) -&gt; Dict:\n    \"\"\"From *body_dict*, construct data for ManyBodyResultProperties.\n\n    Parameters\n    ----------\n    bsse\n        Label for a single many-body treatment, generally a value of BsseEnum.\n    prop\n        Label for a single property, generally a value of DriverEnum.\n    body_dict\n        Dictionary of minimal per-body info already specialized for property *prop* and treatment\n        *bsse*. May contain either total data or interaction data (cummulative, not additive) from\n        1-body to max_nbody-body (see also *supersystem_ie_only*). Interaction data signaled by zero\n        float or array for 1-body. May contain data from multiple model chemistry levels.\n    max_nbody\n        _description_\n    embedding\n        Is charge embedding enabled, by default False?\n    supersystem_ie_only\n        Is data available in *body_dict* only for 1-body (possibly zero) and nfr-body levels?\n        By default False: data is available for consecutive levels, up to max_nbody-body.\n    has_supersystem\n        Whether contributions higher than max_nbody are a summary correction.\n\n    Returns\n    -------\n    dict\n        _description_. Empty return if *embedding* enabled.\n    \"\"\"\n    bsse = bsse.lower()\n    prop = prop.lower()\n    previous_e = body_dict[1]\n    property_shape = find_shape(previous_e)\n    tot_e = bool(np.count_nonzero(previous_e))\n    nbody_range = list(body_dict)\n    nbody_range.sort()\n    res = {}\n\n    if tot_e:\n        res[f\"{bsse}_corrected_total_{prop}\"] = body_dict[max_nbody]\n    res[f\"{bsse}_corrected_interaction_{prop}\"] = body_dict[max_nbody] - body_dict[1]\n    res[f\"{bsse}_corrected_interaction_{prop}_through_1_body\"] = shaped_zero(property_shape)\n\n    if supersystem_ie_only:\n        nfr = nbody_range[-1]\n        for nb in [nfr]:\n            res[f\"{bsse}_corrected_interaction_{prop}_through_{nb}_body\"] = body_dict[nb] - body_dict[1]\n            if nb == 2:\n                res[f\"{bsse}_corrected_{nb}_body_contribution_to_{prop}\"] = body_dict[nb] - body_dict[nb - 1]\n        if tot_e:\n            for nb in [1, nfr]:\n                res[f\"{bsse}_corrected_total_{prop}_through_{nb}_body\"] = body_dict[nb]\n    elif has_supersystem:\n        nfr = nbody_range[-1]\n        res[f\"{bsse}_corrected_interaction_{prop}\"] = body_dict[nfr] - body_dict[1]  # reset\n        for nb in range(2, max_nbody + 1):\n            res[f\"{bsse}_corrected_interaction_{prop}_through_{nb}_body\"] = body_dict[nb] - body_dict[1]\n            res[f\"{bsse}_corrected_{nb}_body_contribution_to_{prop}\"] = body_dict[nb] - body_dict[nb - 1]\n        for nb in [nfr]:\n            res[f\"{bsse}_corrected_interaction_{prop}_through_{nb}_body\"] = body_dict[nb] - body_dict[1]\n            res[f\"{bsse}_corrected_{nb}_body_contribution_to_{prop}\"] = body_dict[nb] - body_dict[max_nbody]\n        if tot_e:\n            res[f\"{bsse}_corrected_total_{prop}\"] = body_dict[nfr]  # reset\n            for nb in nbody_range:\n                res[f\"{bsse}_corrected_total_{prop}_through_{nb}_body\"] = body_dict[nb]\n    else:\n        for nb in range(2, max(nbody_range) + 1):\n            res[f\"{bsse}_corrected_interaction_{prop}_through_{nb}_body\"] = body_dict[nb] - body_dict[1]\n            res[f\"{bsse}_corrected_{nb}_body_contribution_to_{prop}\"] = body_dict[nb] - body_dict[nb - 1]\n        if tot_e:\n            for nb in nbody_range:\n                res[f\"{bsse}_corrected_total_{prop}_through_{nb}_body\"] = body_dict[nb]\n\n    if embedding:\n        res = {k: v for k, v in res.items() if \"interaction\" not in k}\n\n    return res\n</code></pre>"},{"location":"api/#qcmanybody.utils.provenance_stamp","title":"provenance_stamp","text":"<pre><code>provenance_stamp(routine: str) -&gt; Dict[str, str]\n</code></pre> <p>Return dictionary satisfying QCSchema, https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41 with QCManyBody's credentials for creator and version. The generating routine's name is passed in through <code>routine</code>.</p> <pre><code>qcmb.utils.provenance_stamp(__name__)\n#&gt; {'creator': 'QCManyBody', 'version': '0.2.2', 'routine': '__main__'}\n</code></pre> Source code in <code>qcmanybody/utils.py</code> <pre><code>def provenance_stamp(routine: str) -&gt; Dict[str, str]:\n    \"\"\"Return dictionary satisfying QCSchema,\n    https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41\n    with QCManyBody's credentials for creator and version. The\n    generating routine's name is passed in through `routine`.\n\n    ```python\n    qcmb.utils.provenance_stamp(__name__)\n    #&gt; {'creator': 'QCManyBody', 'version': '0.2.2', 'routine': '__main__'}\n    ```\n    \"\"\"\n    import qcmanybody\n\n    return {\"creator\": \"QCManyBody\", \"version\": qcmanybody.__version__, \"routine\": routine}\n</code></pre>"},{"location":"api/#qcmanybody.utils.translate_qcvariables","title":"translate_qcvariables","text":"<pre><code>translate_qcvariables(varsmap: Mapping[str, Any]) -&gt; Dict[str, Any]\n</code></pre> <p>Translate between ManyBody results in Psi4/QCDB terminology (qcvars) and QCSchema terminology (skprops).</p> <p>Parameters:</p> Name Type Description Default <code>varsmap</code> <code>Mapping[str, Any]</code> <p>Dictionary with keys all members of QCVariables or ManyBodyResultProperties and arbitrary values.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>varsmap with keys swapped to other set. Untranslatable keys are omitted.</p> Source code in <code>qcmanybody/utils.py</code> <pre><code>def translate_qcvariables(varsmap: Mapping[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Translate between ManyBody results in Psi4/QCDB terminology (qcvars) and QCSchema terminology (skprops).\n\n    Parameters\n    ----------\n    varsmap\n        Dictionary with keys all members of QCVariables or ManyBodyResultProperties and arbitrary values.\n\n    Returns\n    -------\n    dict\n        varsmap with keys swapped to other set. Untranslatable keys are omitted.\n\n    \"\"\"\n    from qcmanybody.models import ManyBodyResultProperties\n\n    # identify direction of translation\n    qcv2skp = any([\" \" in lbl for lbl in varsmap])\n    labelmap = ManyBodyResultProperties.to_qcvariables(reverse=qcv2skp)\n\n    return {labelmap[lbl]: data for lbl, data in varsmap.items() if lbl in labelmap}\n</code></pre>"},{"location":"api/#qcmanybody.utils.modelchem_labels","title":"modelchem_labels","text":"<pre><code>modelchem_labels(nb_per_mc: Dict[str, List[Union[int, Literal['supersystem']]]], presorted: bool = False) -&gt; Dict[Union[int, Literal['supersystem']], Tuple[str, str, str]]\n</code></pre> <p>Form ordinal and letter labels for model chemistries.</p> <p>Parameters:</p> Name Type Description Default <code>nb_per_mc</code> <code>Dict[str, List[Union[int, Literal['supersystem']]]]</code> <p>Dictionary mapping model chemistries to lists of n-body levels computed. If a model chemistry is supersystem, the value should be [\"supersystem\"]. Generally, this is the <code>ManyBodyCore.nbodies_per_mc_level</code> data structure.</p> required <code>presorted</code> <code>bool</code> <p>If True, the input dictionary keys and values are already sorted by increasing n-body level. This is the case when the input is <code>ManyBodyCore.nbodies_per_mc_level</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>mc_per_nb</code> <p>Dictionary mapping n-body levels to a tuple of full model chemistry label, single-letter ordinal label, and n-body-levels-covered label.</p> <pre><code>modelchem_labels({'ccsd': [1], 'mp2': [2, 3], 'hf': [4]})\n#&gt; {1: ('ccsd', '\u00a7A', '\u00a71'), 2: ('mp2', '\u00a7B', '\u00a723'), 3: ('mp2', '\u00a7B', '\u00a723'), 4: ('hf', '\u00a7C', '\u00a74')}\n\nmodelchem_labels({'hi': [1, 2, 3], 'md': [4], 'md2': [5, 6, 7, 8, 9, 10], 'lo': ['supersystem']})\n#&gt; {1: ('hi', '\u00a7A', '\u00a7123'), 2: ('hi', '\u00a7A', '\u00a7123'), 3: ('hi', '\u00a7A', '\u00a7123'),\n#   4: ('md', '\u00a7B', '\u00a74'),\n#   5: ('md2', '\u00a7C', '\u00a7&lt;10'), 6: ('md2', '\u00a7C', '\u00a7&lt;10'), 7: ('md2', '\u00a7C', '\u00a7&lt;10'), 8: ('md2', '\u00a7C', '\u00a7&lt;10'), 9: ('md2', '\u00a7C', '\u00a7&lt;10'), 10: ('md2', '\u00a7C', '\u00a7&lt;10'),\n#   \"supersystem\": ('lo', '\u00a7D', '\u00a7SS')}\n</code></pre> Source code in <code>qcmanybody/utils.py</code> <pre><code>def modelchem_labels(\n    nb_per_mc: Dict[str, List[Union[int, Literal[\"supersystem\"]]]], presorted: bool = False\n) -&gt; Dict[Union[int, Literal[\"supersystem\"]], Tuple[str, str, str]]:\n    \"\"\"Form ordinal and letter labels for model chemistries.\n\n    Parameters\n    ----------\n    nb_per_mc\n        Dictionary mapping model chemistries to lists of n-body levels computed.\n        If a model chemistry is supersystem, the value should be [\"supersystem\"].\n        Generally, this is the `ManyBodyCore.nbodies_per_mc_level` data structure.\n    presorted\n        If True, the input dictionary keys and values are already sorted by increasing n-body level.\n        This is the case when the input is `ManyBodyCore.nbodies_per_mc_level`.\n\n    Returns\n    -------\n    mc_per_nb\n        Dictionary mapping n-body levels to a tuple of full model chemistry label,\n        single-letter ordinal label, and n-body-levels-covered label.\n\n        ```python\n        modelchem_labels({'ccsd': [1], 'mp2': [2, 3], 'hf': [4]})\n        #&gt; {1: ('ccsd', '\u00a7A', '\u00a71'), 2: ('mp2', '\u00a7B', '\u00a723'), 3: ('mp2', '\u00a7B', '\u00a723'), 4: ('hf', '\u00a7C', '\u00a74')}\n\n        modelchem_labels({'hi': [1, 2, 3], 'md': [4], 'md2': [5, 6, 7, 8, 9, 10], 'lo': ['supersystem']})\n        #&gt; {1: ('hi', '\u00a7A', '\u00a7123'), 2: ('hi', '\u00a7A', '\u00a7123'), 3: ('hi', '\u00a7A', '\u00a7123'),\n        #   4: ('md', '\u00a7B', '\u00a74'),\n        #   5: ('md2', '\u00a7C', '\u00a7&lt;10'), 6: ('md2', '\u00a7C', '\u00a7&lt;10'), 7: ('md2', '\u00a7C', '\u00a7&lt;10'), 8: ('md2', '\u00a7C', '\u00a7&lt;10'), 9: ('md2', '\u00a7C', '\u00a7&lt;10'), 10: ('md2', '\u00a7C', '\u00a7&lt;10'),\n        #   \"supersystem\": ('lo', '\u00a7D', '\u00a7SS')}\n        ```\n    \"\"\"\n    sorted_nb_per_mc = {\n        k: sorted(v)\n        for (k, v) in sorted(\n            nb_per_mc.items(), key=lambda mc_nbs: sorted([1000] if (mc_nbs[1] == [\"supersystem\"]) else mc_nbs[1])[0]\n        )\n    }\n    if presorted:\n        assert (\n            sorted_nb_per_mc == nb_per_mc\n        ), f\"If presorted, input dictionary should be sorted. {nb_per_mc} != {sorted_nb_per_mc}   \"\n\n    lvl_lbl = {}\n    for mc, nbs in sorted_nb_per_mc.items():\n        if nbs == [\"supersystem\"]:\n            lvl_lbl[mc] = \"\u00a7SS\"\n        elif max(nbs) &gt; 9:\n            lvl_lbl[mc] = f\"\u00a7&lt;{max(nbs)}\"\n        else:\n            lvl_lbl[mc] = f\"\u00a7{''.join(map(str, sorted(nbs)))}\"\n\n    indexed_mc = {k: i for i, k in enumerate(sorted_nb_per_mc.keys())}\n\n    mc_per_nb = {\n        nb: (mc, f\"\u00a7{string.ascii_uppercase[indexed_mc[mc]]}\", lvl_lbl[mc])\n        for mc, nbs in sorted_nb_per_mc.items()\n        for nb in nbs\n    }\n\n    return mc_per_nb\n</code></pre>"},{"location":"api/#qcmanybody.builder","title":"qcmanybody.builder","text":""},{"location":"api/#qcmanybody.builder.build_nbody_compute_list","title":"build_nbody_compute_list","text":"<pre><code>build_nbody_compute_list(bsse_type: Iterable[BsseEnum], nfragments: int, nbodies: Iterable[Union[int, Literal['supersystem']]], return_total_data: bool, supersystem_ie_only: bool, supersystem_max_nbody: Optional[int] = None) -&gt; Dict[str, Dict[int, Set[FragBasIndex]]]\n</code></pre> <p>Generates lists of N-Body computations needed for requested BSSE treatments.</p> <p>Parameters:</p> Name Type Description Default <code>bsse_type</code> <code>Iterable[BsseEnum]</code> <p>Requested BSSE treatments.</p> required <code>nfragments</code> <code>int</code> <p>Number of distinct fragments comprising the full molecular supersystem.</p> required <code>nbodies</code> <code>Iterable[Union[int, Literal['supersystem']]]</code> <p>List of n-body levels (e.g., <code>[2]</code> or <code>[1, 2]</code> or <code>[\"supersystem\"]</code>) for which to generate tasks. Note the natural 1-indexing, so <code>[1]</code> covers one-body contributions.</p> required <code>return_total_data</code> <code>bool</code> <p>Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested, as opposed to interaction data (False).</p> required <code>supersystem_ie_only</code> <code>bool</code> <p>Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) \" analysis, thereby omitting intermediate-body calculations.</p> required <code>supersystem_max_nbody</code> <code>Optional[int]</code> <p>Maximum n-body to use for a supersystem calculation. Must be specified if \"supersystem\" is in <code>nbodies</code></p> <code>None</code> <p>Returns:</p> Type Description <code>compute_dict</code> <p>Dictionary containing subdicts enumerating compute lists for each possible BSSE treatment. Subdict keys are n-body levels and values are sets of all the <code>mc_(frag, bas)</code> indices needed to compute that n-body level. A given index can appear multiple times within a subdict and among subdicts.</p> <pre><code>compute_dict[\"cp\"] = {\n    1: set(),\n    2: {((1,), (1, 2)),\n        ((2,), (1, 2)),\n        ((1, 2), (1, 2))}\n}\n</code></pre> <p>Subdicts below are always returned. Any may be empty if not requested through bsse_type.</p> <ul> <li><code>'all'</code> |w---w| full list of computations required</li> <li><code>'cp'</code> |w---w| list of computations required for CP procedure</li> <li><code>'nocp'</code> |w---w| list of computations required for non-CP procedure</li> <li><code>'vmfc_compute'</code> |w---w| list of computations required for VMFC procedure</li> <li><code>'vmfc_levels'</code> |w---w| list of levels required for VMFC procedure</li> </ul> Source code in <code>qcmanybody/builder.py</code> <pre><code>def build_nbody_compute_list(\n    bsse_type: Iterable[BsseEnum],\n    nfragments: int,\n    nbodies: Iterable[Union[int, Literal[\"supersystem\"]]],\n    return_total_data: bool,\n    supersystem_ie_only: bool,\n    supersystem_max_nbody: Optional[int] = None,\n) -&gt; Dict[str, Dict[int, Set[FragBasIndex]]]:\n    \"\"\"Generates lists of N-Body computations needed for requested BSSE treatments.\n\n    Parameters\n    ----------\n    bsse_type\n        Requested BSSE treatments.\n    nfragments\n        Number of distinct fragments comprising the full molecular supersystem.\n    nbodies\n        List of n-body levels (e.g., `[2]` or `[1, 2]` or `[\"supersystem\"]`) for which to generate tasks.\n        Note the natural 1-indexing, so `[1]` covers one-body contributions.\n    return_total_data\n        Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested,\n        as opposed to interaction data (False).\n    supersystem_ie_only\n        Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) \"\n        analysis, thereby omitting intermediate-body calculations.\n    supersystem_max_nbody\n        Maximum n-body to use for a supersystem calculation. Must be specified if \"supersystem\" is in `nbodies`\n\n    Returns\n    -------\n    compute_dict\n        Dictionary containing subdicts enumerating compute lists for each possible BSSE treatment.\n        Subdict keys are n-body levels and values are sets of all the `mc_(frag, bas)` indices\n        needed to compute that n-body level. A given index can appear multiple times within a\n        subdict and among subdicts.\n\n            compute_dict[\"cp\"] = {\n                1: set(),\n                2: {((1,), (1, 2)),\n                    ((2,), (1, 2)),\n                    ((1, 2), (1, 2))}\n            }\n\n        Subdicts below are always returned. Any may be empty if not requested through *bsse_type*.\n\n        * ``'all'`` |w---w| full list of computations required\n        * ``'cp'`` |w---w| list of computations required for CP procedure\n        * ``'nocp'`` |w---w| list of computations required for non-CP procedure\n        * ``'vmfc_compute'`` |w---w| list of computations required for VMFC procedure\n        * ``'vmfc_levels'`` |w---w| list of levels required for VMFC procedure\n\n    \"\"\"\n\n    include_supersystem = False\n    if \"supersystem\" in nbodies:\n        if supersystem_max_nbody is None:\n            raise ValueError(\"supersystem_max_nbody must be provided if 'supersystem' contains nbodies\")\n\n        include_supersystem = True\n\n    nbodies: List[int] = [x for x in nbodies if x != \"supersystem\"]\n\n    # What levels do we need?\n    fragment_range = range(1, nfragments + 1)\n\n    # Need nbodies and all lower-body in full basis\n    cp_compute_list = {x: set() for x in nbodies}\n    nocp_compute_list = {x: set() for x in nbodies}\n    vmfc_compute_list = {x: set() for x in nbodies}\n    vmfc_level_list = {x: set() for x in nbodies}  # Need to sum something slightly different\n\n    # Verify proper passing of bsse_type. already validated in Computer\n    bsse_type_remainder = set(bsse_type) - {e.value for e in BsseEnum}\n    if bsse_type_remainder:\n        raise RuntimeError(f\"Unrecognized BSSE type(s): {bsse_type_remainder}\")\n\n    # Build up compute sets\n    if \"cp\" in bsse_type:\n        # Everything is in counterpoise/nfr-mer basis\n        basis_tuple = tuple(fragment_range)\n\n        if supersystem_ie_only:\n            for sublevel in [1, nfragments]:\n                for x in itertools.combinations(fragment_range, sublevel):\n                    cp_compute_list[nfragments].add((x, basis_tuple))\n        else:\n            for nb in nbodies:\n                # Note A.1: nb=1 is skipped because the nfr-mer-basis monomer\n                #   contributions cancel at 1-body. These skipped tasks will be\n                #   ordered anyways if higher bodies are requested. Monomers for\n                #   the purpose of total energies use monomer basis, not these\n                #   skipped tasks. See coordinating Note A.2 .\n                if nb &gt; 1:\n                    for sublevel in range(1, nb + 1):\n                        for x in itertools.combinations(fragment_range, sublevel):\n                            cp_compute_list[nb].add((x, basis_tuple))\n\n    if \"nocp\" in bsse_type:\n        # Everything in natural/n-mer basis\n        if supersystem_ie_only:\n            for sublevel in [1, nfragments]:\n                for x in itertools.combinations(fragment_range, sublevel):\n                    nocp_compute_list[nfragments].add((x, x))\n        else:\n            for nb in nbodies:\n                for sublevel in range(1, nb + 1):\n                    for x in itertools.combinations(fragment_range, sublevel):\n                        nocp_compute_list[nb].add((x, x))\n\n    if \"vmfc\" in bsse_type:\n        # Like a CP for all combinations of pairs or greater\n        for nb in nbodies:\n            for cp_combos in itertools.combinations(fragment_range, nb):\n                basis_tuple = tuple(cp_combos)\n                # TODO vmfc_compute_list and vmfc_level_list are identical, so consolidate\n                for interior_nbody in range(1, nb + 1):\n                    for x in itertools.combinations(cp_combos, interior_nbody):\n                        combo_tuple = (x, basis_tuple)\n                        vmfc_compute_list[nb].add(combo_tuple)\n                        vmfc_level_list[len(basis_tuple)].add(combo_tuple)\n\n    if return_total_data and 1 in nbodies:\n        # Monomers in monomer basis\n        nocp_compute_list.setdefault(1, set())\n        for ifr in fragment_range:\n            nocp_compute_list[1].add(((ifr,), (ifr,)))\n\n    if include_supersystem:\n        # Add supersystem info to the compute list (nocp only)\n        for nb in range(1, supersystem_max_nbody + 1):\n            cp_compute_list.setdefault(nb, set())\n            nocp_compute_list.setdefault(nb, set())\n            vmfc_compute_list.setdefault(nb, set())\n            for sublevel in range(1, nb + 1):\n                for x in itertools.combinations(fragment_range, sublevel):\n                    nocp_compute_list[nb].add((x, x))\n\n        # Add the total supersystem (nfragments@nfragments)\n        nocp_compute_list.setdefault(nfragments, set())\n        nocp_compute_list[nfragments].add((tuple(fragment_range), tuple(fragment_range)))\n\n    # Build a comprehensive compute range\n    # * do not use list length to count number of {nb}-body computations\n    compute_list = {x: set() for x in nbodies}\n    for nb in nbodies:\n        compute_list[nb] |= cp_compute_list[nb]\n        compute_list[nb] |= nocp_compute_list[nb]\n        compute_list[nb] |= vmfc_compute_list[nb]\n\n    if include_supersystem:\n        for nb, lst in nocp_compute_list.items():\n            compute_list.setdefault(nb, set())\n            compute_list[nb] |= lst\n\n    compute_dict = {\n        \"all\": compute_list,\n        \"cp\": cp_compute_list,\n        \"nocp\": nocp_compute_list,\n        \"vmfc_compute\": vmfc_compute_list,\n        \"vmfc_levels\": vmfc_level_list,\n    }\n    return compute_dict\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v040-2025-01-16","title":"v0.4.0 / 2025-01-16","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>#36 Feature -- as the embedded point charges aren't fully validated    and (in the QCEngine computer function of the high-level interface) only work with Psi4 anyways, they are now hidden.    Set environment variable <code>QCMANYBODY_EMBEDDING_CHARGES=1</code> to access functionality. @loriab</li> </ul>"},{"location":"changelog/#new-features","title":"New Features","text":""},{"location":"changelog/#enhancements","title":"Enhancements","text":"<ul> <li>#36 Utils -- when adding up results from many molecular species,    now the compensated sums <code>math.fsum</code> or <code>numpy.sum</code> are used.</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/#misc","title":"Misc.","text":"<ul> <li>Maint -- pinned to QCElemental &lt;0.70 to use only QCSchema v1.</li> </ul>"},{"location":"changelog/#v030-2024-07-21","title":"v0.3.0 / 2024-07-21","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>#28 Intf -- low-level \"core\" interface renamed from    <code>ManyBodyCalculator</code> to <code>ManyBodyCore</code>. The old name will continue to work for a few months. Also, its file changed    from <code>manybody.py</code> to <code>core.py</code> but it was already a top-level import. @loriab</li> <li>#30 Intf -- low-level \"core\" interface now requires named arguments    beyond the first recognizable ones (mol, bsse_type, levels). @loriab</li> <li>#32 Intf -- \"high-level\" interface now no longer stores QCVariables    (or any other results dicts) in extras @loriab</li> <li>#32 Utils -- <code>qcmanybody.utils.collect_vars</code> now returns with keys     from ManyBodyResultProperties rather than QCVariables. @loriab</li> <li>#32 Utils -- arguments rearranged in    <code>qcmanybody.tests.utils.run_qcengine</code> (use serial backend for core interface) to align with <code>ManyBodyCore</code> init    arguments. @loriab</li> </ul>"},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li>#32 Schema -- a new function    <code>ManyBodyResultProperties.to_qcvariables()</code> returns a translation map to QCVariables keys. @loriab</li> <li>#32 Schema -- a new function    <code>qcmanybody.utils.translate_qcvariables(map)</code> switches between QCVariable and QCSchema keys. @loriab</li> <li>#33 Schema -- <code>ManyBodySpecification.extras</code> added. @loriab</li> <li>#34 Schema -- Add schema_version to <code>AtomicSpecification</code>,    <code>ManyBodySpecification</code>, <code>ManyBodyKeywords</code>, <code>ManyBodyInput</code>, and <code>ManyBodyResultProperties</code>. @loriab</li> </ul>"},{"location":"changelog/#enhancements_1","title":"Enhancements","text":"<ul> <li>#28 Intf -- high-level interface is now importable from the top level    module. @loriab</li> <li>#29 Maint -- QCEngine is needed only for the continuous running    function of the high-level interface, so making it an optional dependency. @loriab</li> <li>#30 Intf -- low-level \"core\" interface now accepts a molecule in    partial schema dictionary format rather than requiring a constructed <code>qcelemental.Molecule</code> object. If the molecule    is a single large fragment, an error is thrown. @loriab</li> <li>#30 Docs -- add end-to-end demos in test_examples. @loriab</li> <li>#31 Schema -- add \"none\" as a bsse_type alias to \"nocp\". @loriab</li> <li>#34 Schema -- Allow environment variable QCMANYBODY_MAX_NBODY to    influence the body-level to which <code>ManyBodyResultProperties</code> is defined added. @loriab</li> <li>#34 Schema -- added discriminator to input for    <code>GeneralizedOptimizationInput</code> and <code>GeneralizedOptimizationResult</code> models to allow input from dicts (rather than    models) in OptKing. Further specialized QCElemental. @loriab</li> <li>#34 Schema -- <code>ManyBodyResultProperties</code> is still only explicitly    enumerated up to tetramers, but now it allows through higher-body fields when they match a pattern. @loriab</li> <li>#34 Maint -- start testing optimizations through QCEngine. @loriab</li> <li>#34 Util -- add <code>labeler(..., opaque=False)</code> option to produce    eye-friendly <code>(1)@(1, 2)</code> style lablels as well as the semi-opaque internal style. Also always convent single ints    to tuples now. Function <code>delabeler</code> can decode the new style. @loriab</li> <li>#34 Intf -- sort \"core\" <code>nbodies_per_mc_level</code> dictionary so model    chemistries are in a predictable 1b, 2b, ..., supersystem order. Check that high-level (different data structure) agrees.</li> <li>#34 Util -- add short ordinal model chemistry level (e.g., \u00a7A) to the    <code>format_calc_plan</code> and <code>print_nbody_energy</code> summaries. @loriab</li> <li>#34 Util -- add function <code>modelchem_labels</code> to associate n-body    level, model chemistry level, one-char ordinal modelchem label, and n-bodies-covered modelchem label. @loriab</li> </ul>"},{"location":"changelog/#v021-2024-05-14","title":"v0.2.1 / 2024-05-14","text":""},{"location":"changelog/#enhancements_2","title":"Enhancements","text":"<ul> <li>#27 Intf -- move high-level interface from   <code>qcmb.qcng_computer.ManyBodyComputerQCNG</code> to <code>qcmb.computer.ManyBodyComputer</code>. Suppressed remaining printing. @loriab</li> </ul>"},{"location":"changelog/#v020-2024-05-13","title":"v0.2.0 / 2024-05-13","text":""},{"location":"changelog/#new-features_2","title":"New Features","text":"<ul> <li>#25 Schema -- added a new field <code>ManyBodyResults.component_results</code>   to store subsystem <code>AtomicResult</code>s (or other Result if layered computation). By default this is not stored, but it can   be with <code>ManyBodyInput.protocols.component_results = \"all\"</code>. @loriab</li> <li>#25 Schema -- added <code>GeneralizedOptimizationInput</code> and   <code>GeneralizedOptimizationResult</code> models as temporary extensions of <code>OptimizationInput/Result</code> when the optimizer can   run <code>ManyBodyInput</code>s through QCEngine, not just <code>AtomicInput</code>s. Needs special QCElemental, QCEngine, and OptKing to   work for now. @loriab</li> </ul>"},{"location":"changelog/#enhancements_3","title":"Enhancements","text":"<ul> <li>#22 Intf -- move high-level interface to main directory and remove   unused functions. Most common route into interface is now: <code>qcmb.ManyBodyComputerQCNG.from_manybodyinput</code>. @loriab</li> <li>#25 Schema -- <code>AtomicSpecification.protocols</code> set in   <code>ManyBodySpecification.specification</code> will now be observed. @loriab</li> <li>#26 Schema -- add <code>AtomicSpecification.extras</code>. @loriab</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>#25 Schema -- <code>ManyBodyKeywords.embedding_charges</code> now default to None   rather than empty dict. @loriab</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc.","text":"<ul> <li>#21 Docs -- installation and molecule. @bennybp</li> <li>#24 Intf -- release \"frozen\" pydantic on high-level   ManyBodyComputerQCNG, so core-interface ManyBodyCalculator can live on the class. @loriab</li> <li>#26 Cleanup -- remove most debug printing. @loriab</li> </ul>"},{"location":"changelog/#v010-2024-04-24","title":"v0.1.0 / 2024-04-24","text":""},{"location":"changelog/#new-features_3","title":"New Features","text":"<ul> <li>Runs CP, NoCP, VMFC energies, gradients, and Hessians. @bennybp @loriab</li> </ul>"},{"location":"core-interface/","title":"Core Interface","text":"<p>The core interface of QCManyBody is designed to allow for more flexibility in how the calculations are run. The primary responsibilities of the core interface are:</p> <ol> <li>Given a molecule and desired levels of MBE, return the fragments and levels that must be computed for each fragment</li> <li>Given a dictionary of the results of those computations, analyze those results and calculate the desired many-body properties</li> </ol> <p>Note that the user is expected to run the calculations themselves, and the core interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#using-the-core-interface","title":"Using the core interface","text":"<p>The core interface is accessed through the <code>ManyBodyCore</code> class.</p> <p>The first step is to create a molecule. This molecule is a QCElemental molecule object, and must contain fragments. (see also: moleule input)</p> <pre><code>from qcelemental.models import Molecule\n\n# Create a molecule with 3 neon atoms, each as its own fragment\n\nmol = Molecule(symbols=[\"ne\", \"ne\", \"ne\"],\n               geometry=[[0,0,0], [0,0,2], [0,0,4]],\n               fragments=[[0], [1], [2]])\n</code></pre> <p>Next, create a <code>ManyBodyCore</code> object. This object is constructed using the molecule, the desired BSSE correction, levels of MBE, and other options of the MBE.</p> <pre><code>from qcmanybody import ManyBodyCore\n\nmbc = ManyBodyCore(molecule=mol,\n                   bsse_type=[\"cp\"],\n                   levels={1: \"ccsd/cc-pvtz\",\n                           2: \"mp2/cc-pvdz\",\n                           3: \"mp2/cc-pvdz\"},\n                   return_total_data: True,\n                   supersystem_ie_only: False,\n                   embedding_charges: None)\n</code></pre> <p>The <code>levels</code> option is a dictionary that specifies the n-body level as a key, then an arbitrary string as the description of the calculation to be performed at the n-body level. This string is termed the 'model chemistry' is completely arbitrary; it only has meaning to the user, and the user is expected to map these strings to some meaningful definition of a calculation.</p> <p>Note: The core interface is less flexible than the high-level interface when it comes to the <code>levels</code> option.     In the core interface, all levels must be accounted for (that is, keys must go from 1 to the maximum     nbody you would like to calculate). All levels must be present even if the model chemistry     is the same for all levels.</p> <p>For a complete discussion of the other options available in the <code>ManyBodyCore</code> object, see the keywords discussion the <code>ManyBodyCore API documentation</code>.</p> <p>The next step is to obtain the calculations to be run from the <code>ManyBodyCore</code> object. This is done with a python generator function <code>iterate_molecules</code> that returns a tuple. This tuple contains</p> <ol> <li>The string describing the calculation to be run (the model chemistry string, as defined in the <code>levels</code> dictionary)</li> <li>A label for the calculation. This label is opaque to the user but used to identify the calculation when analyzing the results.</li> <li>A <code>Molecule</code> object that contains the cluster of fragments to be computed.</li> </ol> <pre><code>calculation_results = {}\nfor model_chemistry, label, mol_cluster in mbc.iterate_molecules():\n    calculation_results[label] = run_calculation(mol_cluster, model_chemistry)\n</code></pre> <p>Note that it is entirely up to the user to run the calculation somehow - this level of interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#results-dictionary","title":"Results dictionary","text":"<p>The data returned from the calculations is expected to be stored in a nested dictionary. The level is the opaque label as given from the <code>QCManyBodyCore</code>. The second level is the name of the property.</p> <pre><code>calculation_results = {\n    'label1': {\n        'energy': -1.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]],\n    },\n    'label2': {\n        'energy': -2.0,\n        'gradient': [[4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n    'label3': {\n        'energy': -3.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n}\n</code></pre>"},{"location":"core-interface/#analysis","title":"Analysis","text":"<p>This result dictionary is all that is needed to perform the final analysis and calculation of the MBE properties.</p> <pre><code>final_results = mbc.analyze(calculation_results)\n</code></pre> <p>For a discussion about what the results contain, see the results documentation.</p>"},{"location":"high-level-interface/","title":"High-Level Interface","text":""},{"location":"keywords/","title":"Keywords and options","text":""},{"location":"keywords/#required","title":"Required","text":""},{"location":"keywords/#molecule","title":"Molecule","text":"<p>The molecule used by QCManyBody is a QCElemental Molecule object. The only requirement for use in QCManyBody is that the molecule has multiple fragments. It is these fragments that will be used in the many-body expansion.</p> <p>Examples:</p> <pre><code>from qcelemental.models import Molecule\n\n# Molecule with 3 neon atoms, each as its own fragment\nne3 = Molecule(symbols=[\"ne\", \"ne\", \"ne\"],\n               geometry=[[0,0,0],[0,0,2],[0,0,4]],\n               fragments=[[0], [1], [2]])\n\n# Water tetramer\nwater4 = Molecule(symbols=['o', 'h', 'h', 'o', 'h', 'h', 'o', 'h', 'h', 'o', 'h', 'h'],\n                  geometry=[[-2.8, -1.2, -0.2], [-1.1, -2.1, -0.0], [-3.8, -2.1,  1.1],\n                            [-2.8, -1.2, -2.2], [-1.1, -2.1, -2.0], [-3.8, -2.1, -1.1],\n                            [-2.8, -1.2, -4.2], [-1.1, -2.1, -4.0], [-3.8, -2.1, -3.1],\n                            [-2.8, -1.2, -6.2], [-1.1, -2.1, -6.0], [-3.8, -2.1, -5.1]],\n                          fragments=[[0,1,2], [3,4,5], [6,7,8], [9,10,11]])\n\n# Water trimer, using the from_data function\n# the -- is used to separate fragments\nwater3 = Molecule.from_data(\n\"\"\"\nO      -2.76373224  -1.24377706  -0.15444566\nH      -1.12357791  -2.06227970  -0.05243799\nH      -3.80792362  -2.08705525   1.06090407\n--\nO       2.46924614  -1.75437739  -0.17092884\nH       3.76368260  -2.21425403   1.00846104\nH       2.30598330   0.07098445  -0.03942473\n--\nO       0.29127930   3.00875625   0.20308515\nH      -1.21253048   1.95820900   0.10303324\nH       0.10002049   4.24958115  -1.10222079\nunits bohr\n\"\"\"\n)\n</code></pre>"},{"location":"keywords/#bsse_type","title":"bsse_type","text":"<p>The <code>bsse_type</code> parameter specifies the type of correction for basis set superposition error (BSSE). Multiple types can be specified, in which case the results will include separate fields for each type of correction.</p> <p>Valid types are:</p> <ul> <li><code>nocp</code> - No counterpoise or other corrections applied</li> <li><code>cp</code> - Counterpoise correction</li> <li><code>vmfc</code> - Valiron-Mayer function counterpoise correction</li> </ul>"},{"location":"keywords/#levels-and-max_nbody","title":"levels and max_nbody","text":"<p>Dictionary of different levels of theory for different levels of expansion. The keys are integers or \"supersystem\", and the values are arbitrary strings that represent the model chemistry or level of theory to use for that level. This string is arbitrary and only has meaning to the user - the user is expected to map these strings to some meaningful definition of a calculation.</p> <p>If a <code>supersystem</code> key is present, all higher order n-body effects up to <code>max_nbody</code> will be computed.</p> <p>In the core interface, all levels must be accounted for (that is, keys must go from 1 to the maximum), and <code>max_nbody</code> cannot be specified. In the high-level interface, a computational model fills in for any lower unlisted n-body levels.</p> <p>In the high-level interface, if both levels and max_nbody are provided, they must be consistent.</p> <p>Examples:</p> <ul> <li><code>{2: 'ccsd(t)/cc-pvdz', 3: 'mp2'}</code></li> <li><code>max_nbody=3</code> and <code>levels={1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}</code></li> </ul>"},{"location":"keywords/#keywords-and-options_1","title":"Keywords and Options","text":""},{"location":"keywords/#return_total_data","title":"return_total_data","text":"<p>When set to true, the manybody calculation will return the total data (energy/gradient/hessian/property) of the system. If not, the return will only contain interaction data.</p> <p>Note that the calculation of counterpoise corrected total properties implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than. For some properties such as gradients and hessians, <code>return_total_data = False</code> is rarely useful.</p>"},{"location":"keywords/#supersystem_ie_only","title":"supersystem_ie_only","text":"<p>Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When false, each n-body level in the MBE up through <code>max_nbody</code> will be computed. When true (only allowed for <code>max_nbody = nfragments</code>), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body.</p> <p>When true, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code>; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers).</p> <p>This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code> Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings.</p>"},{"location":"qcschema/","title":"QCSchema","text":"<p>ManyBodyKeywords</p> key type required description default schema_name typing.Literal['qcschema_manybodykeywords'] False qcschema_manybodykeywords schema_version typing.Literal[1] False The version number of <code>schema_name</code> to which this model conforms. 1 bsse_type False Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. [] embedding_charges typing.List[float] False Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. At present, QCManyBody will only accept non-None values of this keyword if environment variable QCMANYBODY_EMBEDDING_CHARGES is set. None return_total_data False When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of counterpoise corrected total energies implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than <code>return_total_data = False</code>. For gradients and Hessians, <code>return_total_data = False</code> is rarely useful. None levels False Dictionary of different levels of theory for different levels of expansion. Note that the primary method_string is not used when this keyword is given. <code>supersystem</code> computes all higher order n-body effects up to the number of fragments; this higher-order correction uses the nocp basis, regardless of bsse_type. A method fills in for any lower unlisted nbody levels. Note that if both this and max_nbody are provided, they must be consistent. Examples: SUPERSYSTEM definition suspect* {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} * Now invalid: {1: 2, 2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} None max_nbody False Maximum number of bodies to include in the many-body treatment. Possible: max_nbody &lt;= nfragments. Default: max_nbody = nfragments. None supersystem_ie_only False Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When False (default), compute each n-body level in the MBE up through <code>max_nbody</code>. When True (only allowed for <code>max_nbody = nfragments</code> ), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body. When True, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code> ; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers). This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code>. Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings. False <p>ManyBodySpecification</p> key type required description default schema_name typing.Literal['qcschema_manybodyspecification'] False qcschema_manybodyspecification schema_version typing.Literal[1] False The version number of <code>schema_name</code> to which this model conforms. 1 keywords True The many-body-specific keywords for user control. None protocols False Protocols regarding the manipulation of a ManyBody output data. ManyBodyProtocols(component_results=) driver True The computation driver; i.e., energy, gradient, hessian. None specification True ??? TODO expand to cbs, fd None extras typing.Any False Additional information to bundle with the computation. Use for schema development and scratch space. {} <p>ManyBodyInput</p> key type required description default schema_name typing.Literal['qcschema_manybodyinput'] False qcschema_manybodyinput schema_version typing.Literal[1] False The version number of <code>schema_name</code> to which this model conforms. 1 specification True ??? None molecule True Target molecule for many-body expansion (MBE) or interaction energy (IE) analysis. None extras typing.Any False Additional information to bundle with the computation. Use for schema development and scratch space. {} <p>Note</p> <p>The properties model is generated dynamically based on a constant <code>MAX_NBODY</code>. To not overload the docs table, this is set to 5, which covers full calculations on tetramers. In practice this isn't a problem for larger clusters because <code>cp_corrected_total_energy_through_12_body</code>, for example, is allowed dynamically for a model instance. Nevertheless, to use a larger <code>ManyBodyKeywords.max_nbody</code>, reset this value outside the interpreter.</p> <pre><code>python -c \"import qcmanybody as qcmb;print(qcmb.models.MAX_NBODY)\"\n#&gt; 5\nexport QCMANYBODY_MAX_NBODY=9  # explicitly enumerates octamer properties\npython -c \"import qcmanybody as qcmb;print(qcmb.models.MAX_NBODY)\"\n#&gt; 9\n</code></pre> <p>ManyBodyResultProperties</p> key type required description default schema_name typing.Literal['qcschema_manybodyproperties'] False qcschema_manybodyproperties schema_version typing.Literal[1] False The version number of <code>schema_name</code> to which this model conforms. 1 calcinfo_nmc False The number of model chemistries applied to n-body levels of the computation. None calcinfo_nfr False The number of fragments in the molecule for the computation. None calcinfo_natom False The number of atoms in the computation. None calcinfo_nmbe False The number of real/ghost molecule patterns for the computation. None nuclear_repulsion_energy False The nuclear repulsion energy. None return_energy False The interaction energy of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Always available. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.energy</code> computations. None return_gradient False The interaction gradient of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Available when driver is g/h. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.gradient</code> computations. None return_hessian False The interaction Hessian of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Available when driver is h. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.hessian</code> computations. None cp_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1. None cp_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2. None cp_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3. None cp_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4. None cp_corrected_total_energy False Best available total energy with cp treatment: cp_corrected_total_energy_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T. None cp_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy False Best available interaction energy with cp treatment: cp_corrected_interaction_energy_through_{max_nbody}_body. Available when cp in bsse_type. None cp_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2. None cp_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3. None cp_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4. None nocp_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1. None nocp_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2. None nocp_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3. None nocp_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4. None nocp_corrected_total_energy False Best available total energy without cp treatment: nocp_corrected_total_energy_through_{max_nbody}_body. Available when nocp in bsse_type. None nocp_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy False Best available interaction energy without cp treatment: nocp_corrected_interaction_energy_through_{max_nbody}_body. Available when nocp in bsse_type. None nocp_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2. None nocp_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3. None nocp_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4. None vmfc_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1. None vmfc_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2. None vmfc_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3. None vmfc_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4. None vmfc_corrected_total_energy False Best available total energy with vmfc treatment: vmfc_corrected_total_energy_through_{max_nbody}_body. Available when vmfc in bsse_type. None vmfc_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy False Best available interaction energy with vmfc treatment: vmfc_corrected_interaction_energy_through_{max_nbody}_body. Available when vmfc in bsse_type. None vmfc_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2. None vmfc_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3. None vmfc_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4. None cp_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1 &amp; driver is g/h. None cp_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2 &amp; driver is g/h. None cp_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3 &amp; driver is g/h. None cp_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4 &amp; driver is g/h. None cp_corrected_total_gradient False Best available total gradient with cp treatment: cp_corrected_total_gradient_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T &amp; driver is g/h. None cp_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient False Best available interaction gradient with cp treatment: cp_corrected_interaction_gradient_through_{max_nbody}_body. Available when cp in bsse_type &amp; driver is g/h. None cp_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None cp_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None cp_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None nocp_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. None nocp_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None nocp_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None nocp_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None nocp_corrected_total_gradient False Best available total gradient without cp treatment: nocp_corrected_total_gradient_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is g/h. None nocp_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient False Best available interaction gradient without cp treatment: nocp_corrected_interaction_gradient_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is g/h. None nocp_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None nocp_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None nocp_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None vmfc_corrected_total_gradient False Best available total gradient with vmfc treatment: vmfc_corrected_total_gradient_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is g/h. None vmfc_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient False Best available interaction gradient with vmfc treatment: vmfc_corrected_interaction_gradient_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is g/h. None vmfc_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None vmfc_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None vmfc_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None cp_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1 &amp; driver is h. None cp_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2 &amp; driver is h. None cp_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3 &amp; driver is h. None cp_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4 &amp; driver is h. None cp_corrected_total_hessian False Best available total Hessian with cp treatment: cp_corrected_total_hessian_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T &amp; driver is h. None cp_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian False Best available interaction Hessian with cp treatment: cp_corrected_interaction_hessian_through_{max_nbody}_body. Available when cp in bsse_type &amp; driver is h. None cp_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None cp_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None cp_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None nocp_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. None nocp_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None nocp_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None nocp_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None nocp_corrected_total_hessian False Best available total Hessian without cp treatment: nocp_corrected_total_hessian_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is h. None nocp_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian False Best available interaction Hessian without cp treatment: nocp_corrected_interaction_hessian_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is h. None nocp_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None nocp_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None nocp_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None vmfc_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. None vmfc_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None vmfc_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None vmfc_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None vmfc_corrected_total_hessian False Best available total Hessian with vmfc treatment: vmfc_corrected_total_hessian_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is h. None vmfc_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian False Best available interaction Hessian with vmfc treatment: vmfc_corrected_interaction_hessian_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is h. None vmfc_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None vmfc_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None vmfc_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None <p>ManyBodyResult</p> key type required description default input_data True None success True A boolean indicator that the operation succeeded or failed. Allows programmatic assessment of all results regardless of if they failed or succeeded by checking <code>result.success</code>. None stdout False The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. None stderr False The standard error of the program execution. None schema_name typing.Literal['qcschema_manybodyresult'] False qcschema_manybodyresult schema_version typing.Literal[1] False The version number of <code>schema_name</code> to which this model conforms. 1 id False The optional ID for the object. None extras typing.Any False Additional information to bundle with the object. Use for schema development and scratch space. {} provenance True Provenance information. None properties True None None component_properties True The key results for each subsystem species computed. Keys contain modelchem, real and ghost information (e.g., <code>'[\"(auto)\", [2], [1, 2, 3]]'</code>). Values are total e/g/H/property results. Array values, if present, are sized and shaped for the full supersystem. None component_results False Detailed results {} return_result typing.Union[float, qcelemental.models.types.Array, typing.Dict[str, typing.Any]] True The primary return specified by the :attr:<code>~qcelemental.models.AtomicInput.driver</code> field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. None"},{"location":"qcschema/#qcmanybody.models.BsseEnum","title":"qcmanybody.models.BsseEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available basis-set superposition error (BSSE) treatments.</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyKeywords","title":"qcmanybody.models.ManyBodyKeywords","text":"<p>               Bases: <code>ProtoModel</code></p> <p>The many-body-specific keywords for user control.</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodySpecification","title":"qcmanybody.models.ManyBodySpecification","text":"<p>               Bases: <code>ProtoModel</code></p> <p>Combining the what (ManyBodyKeywords) with the how (AtomicSpecification).</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyInput","title":"qcmanybody.models.ManyBodyInput","text":"<p>               Bases: <code>ProtoModel</code></p> <p>Combining the what and how (ManyBodySpecification) with the who (Molecule).</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyResultProperties","title":"qcmanybody.models.ManyBodyResultProperties  <code>module-attribute</code>","text":"<pre><code>ManyBodyResultProperties = ProtoModelSkipDefaults\n</code></pre>"},{"location":"qcschema/#qcmanybody.models.ManyBodyResult","title":"qcmanybody.models.ManyBodyResult","text":"<p>               Bases: <code>SuccessfulResultBase</code></p>"},{"location":"results/","title":"Results","text":"<p>The QCManyBody package outputs many results from its analysis.</p> <p>For the core interface, the results are expected to be stored in a nested dictionary. For the high-level interface, the results are stored in a <code>ManyBodyResult</code> object.</p>"},{"location":"results/#fields","title":"Fields","text":""}]}