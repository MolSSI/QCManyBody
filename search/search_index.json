{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QCManyBody Documentation","text":"<p>QCManyBody is a python package for running quantum chemistry many-body expansions and interaction calculations in a package-independent way.</p>"},{"location":"#installation","title":"Installation","text":"<p>QCManyBody is available from PyPI and from conda-forge.</p> <pre><code># Installation from PyPI\npip install qcmanybody\n\n# Installation from conda-forge\nconda install -c conda-forge qcmanybody\n</code></pre> <p>To install the latest development version directly from GitHub, you can use the following command:</p> <pre><code>pip install git+https://github.com/MolSSI/QCManyBody.git\n</code></pre>"},{"location":"#package-overview","title":"Package Overview","text":"<p>The package has two main interfaces. The high-level interface allows for a comprehensive workflow, where the user provides complete information about the calculation, including the full specification (method, basis set, etc.) of the manybody calculation. This is designed to work with QCEngine or other packages that implement the QCSchema.</p> <p>For more information, see High-level interface.</p> <p>QCManyBody also has a core low-level interface that allows for more flexibility in how the calculations are run. This interface generally takes a molecule and an arbitrary definition of quantum chemistry specifications, and expects the user to run them themselves.</p> <p>For more information, see Core interface.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Common Keywords and Options</li> <li>High-level Interface</li> <li>Core Interface</li> <li>Results</li> <li>How-To Guides</li> </ol>"},{"location":"api/","title":"API Documentation","text":"Source code in <code>qcmanybody/core.py</code> <pre><code>def __init__(\n    self,\n    molecule: Molecule,\n    bsse_type: Sequence[BsseEnum],\n    levels: Mapping[Union[int, Literal[\"supersystem\"]], str],\n    *,\n    return_total_data: bool,\n    supersystem_ie_only: bool,\n    embedding_charges: Mapping[int, Sequence[float]],\n):\n    self.embedding_charges = embedding_charges\n    if isinstance(molecule, dict):\n        mol = Molecule(**molecule)\n    elif isinstance(molecule, Molecule):\n        mol = molecule.copy()\n    else:\n        raise ValueError(f\"Molecule input type of {type(molecule)} not understood.\")\n    self.molecule = mol\n    self.bsse_type = [BsseEnum(x) for x in bsse_type]\n    self.return_total_data = return_total_data\n    self.supersystem_ie_only = supersystem_ie_only\n    self.nfragments = len(self.molecule.fragments)\n\n    self.levels = levels\n\n    # Levels without supersystem\n    self.levels_no_ss = {int(k): v for k, v in levels.items() if k != \"supersystem\"}\n\n    # Just a set of all the modelchems\n    self.mc_levels = set(self.levels.values())\n\n    self.max_nbody = max(self.levels_no_ss.keys())\n\n    if len(self.bsse_type) == 0:\n        raise ValueError(\"No BSSE correction specified\")\n\n    if BsseEnum.vmfc in self.bsse_type and len(set(self.levels.values())) == 1:\n        # For single-modelchem VMFC, NOCP &amp; sometimes CP are produced for free\n        if BsseEnum.nocp not in self.bsse_type:\n            self.bsse_type.append(BsseEnum.nocp)\n        if BsseEnum.cp not in self.bsse_type and self.max_nbody == self.nfragments:\n            self.bsse_type.append(BsseEnum.cp)\n\n    self.return_bsse_type = self.bsse_type[0]\n\n    ###############################\n    # Build nbodies_per_mc_level\n    # TODO - use Lori's code\n    # TODO - dict to list of lists to handle non-contiguous levels\n    # TODO multilevel and supersystem_ie_only=T not allowed together\n    # TODO supersystem in levels is not to be trusted -- nfrag only and skips levels\n    max_level = max(self.levels_no_ss.keys())\n\n    if set(range(1, max_level + 1)) != set(self.levels_no_ss.keys()):\n        raise ValueError(f\"Levels must be contiguous from 1 to {max_level}\")\n\n    self.nbodies_per_mc_level: Dict[str, list] = {mc_level: [] for mc_level in self.mc_levels}\n    for k, v in self.levels_no_ss.items():\n        self.nbodies_per_mc_level[v].append(k)\n\n    self.nbodies_per_mc_level = {k: sorted(v) for k, v in self.nbodies_per_mc_level.items()}\n\n    # Supersystem is always at the end\n    if \"supersystem\" in levels:\n        ss_mc = levels[\"supersystem\"]\n        self.nbodies_per_mc_level[ss_mc].append(\"supersystem\")\n\n    # To be built on the fly\n    self.mc_compute_dict = None\n\n    if self.nfragments == 1:\n        # Usually we try to \"pass-through\" edge cases, so a single-fragment mol would return 0 or ordinary energy,\n        #   depending on rtd=T/F. But it seems more likely that user just forgot the fragments field, so we don't\n        #   want to start a full energy on monsterMol. Reconsider handling in future.\n        raise ValueError(\"\"\"QCManyBody: Molecule fragmentation has not been specified through `fragments` field.\"\"\")\n\n    if not np.array_equal(np.concatenate(self.molecule.fragments), np.arange(len(self.molecule.symbols))):\n        raise ValueError(\"\"\"QCManyBody: non-contiguous fragments could be implemented but aren't at present\"\"\")\n\n    # Build size and slices dictionaries. Assumes fragments are contiguous\n    self.fragment_size_dict = {}\n    self.fragment_slice_dict = {}\n    iat = 0\n    for ifr in range(1, self.nfragments + 1):\n        nat = len(self.molecule.fragments[ifr - 1])\n        self.fragment_size_dict[ifr] = nat\n        self.fragment_slice_dict[ifr] = slice(iat, iat + nat)\n        iat += nat\n</code></pre> <p>ManyBodyComputer</p> key type required description default input_data True Input schema containing the relevant settings for performing the many body expansion. This is entirely redundant with the piecemeal assembly of this Computer class and is only stored to be available for error handling and exact reconstruction of ManyBodyResult. None bsse_type False Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. [] molecule True Target molecule for many body expansion (MBE) or interaction energy (IE) analysis. Fragmentation should already be defined in <code>fragments</code> and related fields. None driver True The computation driver; i.e., energy, gradient, hessian. In case of ambiguity (e.g., MBE gradient through finite difference energies or MBE energy through composite method), this field refers to the target derivative, not any means specification. None embedding_charges typing.List[float] False Atom-centered point charges to be used to speed up nbody-level convergence. Charges are placed on molecule fragments whose basis sets are not included in the computation. (An implication is that charges aren't invoked for bsse_type=cp.) Keys: 1-based index of fragment. Values: list of atom charges for that fragment. None return_total_data False When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of counterpoise corrected total energies implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than <code>return_total_data = False</code>. For gradients and Hessians, <code>return_total_data = False</code> is rarely useful. None levels False Dictionary of different levels of theory for different levels of expansion. Note that the primary method_string is not used when this keyword is given. <code>supersystem</code> computes all higher order n-body effects up to the number of fragments; this higher-order correction uses the nocp basis, regardless of bsse_type. A method fills in for any lower unlisted nbody levels. Note that if both this and max_nbody are provided, they must be consistent. Examples: SUPERSYSTEM definition suspect* {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} * Now invalid: {1: 2, 2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} Examples above are processed in the ManyBodyComputer, and once processed, only the values should be used. The keys turn into nbodies_per_mc_level, as notated below. * {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} -&gt; nbodies_per_mc_level=[[1], [2], ['supersystem']] * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} -&gt; nbodies_per_mc_level=[[1, 2], [3]] None max_nbody False Maximum number of bodies to include in the many-body treatment. Possible: max_nbody &lt;= nfragments. Default: max_nbody = nfragments. None supersystem_ie_only False Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When False (default), compute each n-body level in the MBE up through <code>max_nbody</code>. When True (only allowed for <code>max_nbody = nfragments</code> ), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body. When True, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code> ; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers). This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code>. Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings. False task_list typing.Any False {} qcmb_core typing.Any False Low-level interface None"},{"location":"api/#qcmanybody.ManyBodyCore.format_calc_plan","title":"format_calc_plan","text":"<pre><code>format_calc_plan(sset: str = 'all') -&gt; Tuple[str, Dict[str, Dict[int, int]]]\n</code></pre> <p>Formulate per-modelchem and per-body job count data and summary text.</p> <p>Parameters:</p> Name Type Description Default <code>sset</code> <code>str</code> <p>Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.</p> <code>'all'</code> <p>Returns:</p> Type Description <code>info</code> <p>A text summary with per- model chemistry and per- n-body-level job counts.</p> <code>Dict[str, Dict[int, int]]</code> <p>Data structure with outer key mc-label, inner key 1-indexed n-body, value job count.</p> Source code in <code>qcmanybody/core.py</code> <pre><code>def format_calc_plan(self, sset: str = \"all\") -&gt; Tuple[str, Dict[str, Dict[int, int]]]:\n    \"\"\"Formulate per-modelchem and per-body job count data and summary text.\n\n    Parameters\n    ----------\n    sset\n        Among {\"all\", \"nocp\", \"cp\", \"vmfc_compute\"}, which data structure to return.\n\n    Returns\n    -------\n    info\n        A text summary with per- model chemistry and per- n-body-level job counts.\n    Dict[str, Dict[int, int]]\n        Data structure with outer key mc-label, inner key 1-indexed n-body, value job count.\n    \"\"\"\n    # Rearrange compute_list from key nb having values (species) to compute all of that nb\n    #   to key nb having values counting that nb.\n    compute_list_count = {}\n    for mc, compute_dict in self.compute_map.items():\n        compute_list_count[mc] = {}\n        for sub in compute_dict:  # all, nocp, cp, vmfc\n            all_calcs = set().union(*compute_dict[sub].values())\n            compute_list_count[mc][sub] = Counter([len(frag) for (frag, _) in all_calcs])\n\n    info = []\n    for mc, counter in compute_list_count.items():\n        all_counter = counter[\"all\"]\n        info.append(f\"    Model chemistry \\\"{mc}\\\" (???):    {sum(all_counter.values())}\")\n        for nb, count in sorted(all_counter.items()):\n            other_counts = [f\"{sub}: {counter[sub][nb]}\" for sub in [\"nocp\", \"cp\", \"vmfc_compute\"]]\n            info.append(f\"        Number of {nb}-body computations: {count:6} ({', '.join(other_counts)})\")\n        info.append(\"\")\n    info = \"\\n\".join(info)\n\n    logger.info(info)\n    return info, {mc: dsset[sset] for mc, dsset in compute_list_count.items()}\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCore.iterate_molecules","title":"iterate_molecules","text":"<pre><code>iterate_molecules() -&gt; Iterable[Tuple[str, str, Molecule]]\n</code></pre> <p>Iterate over all the molecules needed for the computation.</p> <p>Yields model chemistry, label, and molecule.</p> Source code in <code>qcmanybody/core.py</code> <pre><code>def iterate_molecules(self) -&gt; Iterable[Tuple[str, str, Molecule]]:\n    \"\"\"Iterate over all the molecules needed for the computation.\n\n    Yields model chemistry, label, and molecule.\n    \"\"\"\n\n    done_molecules = set()\n\n    for mc, compute_dict in self.compute_map.items():\n        # TODO - this is a bit of a hack. Lots of duplication when reaching higher nbody\n        for compute_list in compute_dict[\"all\"].values():\n            for real_atoms, basis_atoms in compute_list:\n                label = labeler(mc, real_atoms, basis_atoms)\n                if label in done_molecules:\n                    continue\n\n                ghost_atoms = list(set(basis_atoms) - set(real_atoms))\n\n                # Shift to zero-indexing\n                real_atoms_0 = [x - 1 for x in real_atoms]\n                ghost_atoms_0 = [x - 1 for x in ghost_atoms]\n                mol = self.molecule.get_fragment(real_atoms_0, ghost_atoms_0, orient=False, group_fragments=False)\n                mol = mol.copy(update={\"fix_com\": True, \"fix_orientation\": True})\n\n                if self.embedding_charges:\n                    embedding_frags = list(set(range(1, self.nfragments + 1)) - set(basis_atoms))\n                    charges = []\n                    for ifr in embedding_frags:\n                        positions = self.molecule.get_fragment(ifr-1).geometry.tolist()\n                        charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[ifr])])\n                    mol.extras[\"embedding_charges\"] = charges\n\n                done_molecules.add(label)\n                yield mc, label, mol\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyCore.analyze","title":"analyze","text":"<pre><code>analyze(component_results: Dict[str, Dict[str, Union[float, ndarray]]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>component_results</code> <code>Dict[str, Dict[str, Union[float, ndarray]]]</code> <p>Nested dictionary with results from all individual molecular system calculations, including all subsystem/basis combinations, all model chemistries, and all properties (e.g., e/g/h).</p> <p>For example, the below is the format for a nocp gradient run on a helium dimer with 1-body at CCSD and 2-body at MP2. The outer string key can be generated with the <code>qcmanybody.utils.labeler</code> function. The inner string key is any property; QCManyBody presently knows how to process energy/gradient/Hessian.</p> <p>{'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},  '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},  '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])}, }</p> required Return Source code in <code>qcmanybody/core.py</code> <pre><code>    def analyze(\n        self,\n        component_results: Dict[str, Dict[str, Union[float, np.ndarray]]],\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        component_results\n            Nested dictionary with results from all individual molecular system\n            calculations, including all subsystem/basis combinations, all model\n            chemistries, and all properties (e.g., e/g/h).\n\n            For example, the below is the format for a nocp gradient run on a\n            helium dimer with 1-body at CCSD and 2-body at MP2. The outer string\n            key can be generated with the ``qcmanybody.utils.labeler`` function.\n            The inner string key is any property; QCManyBody presently knows how\n            to process energy/gradient/Hessian.\n\n            {'[\"ccsd\", [1], [1]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"ccsd\", [2], [2]]': {'energy': -2.87, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1], [1]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [2], [2]]': {'energy': -2.86, 'gradient': array([[0., 0., 0.]])},\n             '[\"mp2\", [1, 2], [1, 2]]': {'energy': -5.73, 'gradient': array([[ 0., 0., 0.0053], [ 0., 0., -0.0053]])},\n            }\n\n        Return\n        ------\n\n        \"\"\"\n\n        # All properties that were passed to us\n        # * seed with \"energy\" so free/no-op jobs can process\n        available_properties: Set[str] = {\"energy\"}\n        for property_data in component_results.values():\n            available_properties.update(property_data.keys())\n\n        # reorganize to component_results_inv[property][label] = 1.23\n        component_results_inv = {k: {} for k in available_properties}\n\n        for cluster_label, property_data in component_results.items():\n            for property_label, property_value in property_data.items():\n                component_results_inv[property_label][cluster_label] = property_value\n\n        # Remove any missing data\n        component_results_inv = {k: v for k, v in component_results_inv.items() if v}\n        if not component_results_inv:\n            # Note B: Rarely, \"no results\" is expected, like for CP-only,\n            #   rtd=False, and max_nbody=1. We'll add a dummy entry so\n            #   processing can continue.\n            component_results_inv[\"energy\"] = {'[\"dummy\", [1000], [1000]]': 0.0}\n\n        # Actually analyze\n        is_embedded = bool(self.embedding_charges)\n        component_properties = defaultdict(dict)\n        all_results = {}\n        nbody_dict = {}\n        stdout = \"\"\n#        all_results[\"energy_body_dict\"] = {\"cp\": {1: 0.0}}\n\n        for property_label, property_results in component_results_inv.items():\n            # Expand gradient and hessian\n            if property_label == \"gradient\":\n                property_results = {k: self.resize_gradient(v, delabeler(k)[2]) for k, v in property_results.items()}\n            if property_label == \"hessian\":\n                property_results = {k: self.resize_hessian(v, delabeler(k)[2]) for k, v in property_results.items()}\n\n            r = self._analyze(property_label, property_results)\n            for k, v in property_results.items():\n                component_properties[k][\"calcinfo_natom\"] = len(self.molecule.symbols)\n                component_properties[k][f\"return_{property_label}\"] = v\n            all_results.update(r)\n\n        for bt in self.bsse_type:\n            stdout += print_nbody_energy(\n                all_results[\"energy_body_dict\"][bt],\n                f\"{bt.formal()} ({bt.abbr()})\",\n                self.nfragments,\n                is_embedded,\n                self.supersystem_ie_only,\n                self.max_nbody if self.has_supersystem else None,\n            )\n\n        for property_label in available_properties:\n            for bt in self.bsse_type:\n                nbody_dict.update(\n                    collect_vars(\n                        bt.upper(),\n                        property_label.upper(),\n                        all_results[f\"{property_label}_body_dict\"][bt],\n                        self.max_nbody,\n                        is_embedded,\n                        self.supersystem_ie_only,\n                        self.has_supersystem,\n                    )\n                )\n\n        all_results[\"results\"] = nbody_dict\n        all_results[\"component_properties\"] = component_properties\n\n        # Make dictionary with \"1cp\", \"2cp\", etc\n        ebd = all_results[\"energy_body_dict\"]\n        all_results[\"energy_body_dict\"] = {str(k) + bt: v for bt in ebd for k, v in ebd[bt].items()}\n        all_results[\"stdout\"] = stdout\n\n        return all_results\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer","title":"qcmanybody.ManyBodyComputer","text":"<p>               Bases: <code>BaseComputerQCNG</code></p>"},{"location":"api/#qcmanybody.ManyBodyComputer.input_data","title":"input_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input_data: ManyBodyInput = Field(..., description='Input schema containing the relevant settings for performing the many body expansion. This is entirely redundant with the piecemeal assembly of this Computer class and is only stored to be available for error handling and exact reconstruction of ManyBodyResult.')\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.bsse_type","title":"bsse_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bsse_type: List[BsseEnum] = Field([cp], description=description)\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.molecule","title":"molecule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>molecule: Molecule = Field(..., description='Target molecule for many body expansion (MBE) or interaction energy (IE) analysis. Fragmentation should already be defined in `fragments` and related fields.')\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.driver","title":"driver  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>driver: DriverEnum = Field(..., description='The computation driver; i.e., energy, gradient, hessian. In case of ambiguity (e.g., MBE gradient through finite difference energies or MBE energy through composite method), this field refers to the *target* derivative, not any *means* specification.')\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.embedding_charges","title":"embedding_charges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>embedding_charges: Optional[Dict[int, List[float]]] = Field(None, description=\"Atom-centered point charges to be used to speed up nbody-level convergence. Charges are placed on molecule fragments whose basis sets are not included in the computation. (An implication is that charges aren't invoked for bsse_type=cp.) Keys: 1-based index of fragment. Values: list of atom charges for that fragment.\", json_schema_extra={'shape': ['nfr', '&lt;varies: nat in ifr&gt;']})\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.return_total_data","title":"return_total_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>return_total_data: Optional[bool] = Field(None, validate_default=True, description=description)\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.levels","title":"levels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>levels: Optional[Dict[Union[int, Literal['supersystem']], str]] = Field(None, validate_default=True, description=description + \"Examples above are processed in the ManyBodyComputer, and once processed, only the values should be used. The keys turn into nbodies_per_mc_level, as notated below. * {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} -&gt; nbodies_per_mc_level=[[1], [2], ['supersystem']] * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} -&gt; nbodies_per_mc_level=[[1, 2], [3]] \")\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.max_nbody","title":"max_nbody  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_nbody: Optional[int] = Field(None, validate_default=True, description=description)\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.supersystem_ie_only","title":"supersystem_ie_only  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supersystem_ie_only: Optional[bool] = Field(False, validate_default=True, description=description)\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.task_list","title":"task_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_list: Dict[str, Any] = {}\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.qcmb_core","title":"qcmb_core  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qcmb_core: Optional[Any] = Field(None, description='Low-level interface')\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.nfragments","title":"nfragments  <code>property</code>","text":"<pre><code>nfragments: int\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.nbodies_per_mc_level","title":"nbodies_per_mc_level  <code>property</code>","text":"<pre><code>nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]]\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.Config","title":"Config","text":""},{"location":"api/#qcmanybody.ManyBodyComputer.set_bsse_type","title":"set_bsse_type  <code>classmethod</code>","text":"<pre><code>set_bsse_type(v: Any) -&gt; List[BsseEnum]\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@validator(\"bsse_type\", pre=True)\n@classmethod\ndef set_bsse_type(cls, v: Any) -&gt; List[BsseEnum]:\n    if not isinstance(v, list):\n        v = [v]\n    # emulate ordered set\n    # * bt.lower() as return (w/i `list(dict.fromkeys([bt.lower() ...`)\n    #   works until aliases added to BsseEnum\n    # * BsseEnum[bt].value as return works for good vals, but passing bad\n    #   vals through as bt lets pydantic raise a clearer error message\n    return list(dict.fromkeys([(BsseEnum[bt.lower()].value if bt.lower() in BsseEnum.__members__ else bt.lower()) for bt in v]))\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.set_embedding_charges","title":"set_embedding_charges  <code>classmethod</code>","text":"<pre><code>set_embedding_charges(v, values)\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@validator(\"embedding_charges\", pre=True)\n@classmethod\n# v2: def set_embedding_charges(cls, v: Any, info: FieldValidationInfo) -&gt; Dict[int, List[float]]:\ndef set_embedding_charges(cls, v, values): # -&gt; Dict[int, List[float]]:\n    # print(f\"hit embedding_charges validator with {v}\", end=\"\")\n    nfr = len(values[\"molecule\"].fragments)\n    # v2: if len(v) != info.data[\"nfragments\"]:\n    if v and len(v) != nfr:\n        raise ValueError(f\"embedding_charges dict should have entries for each 1-indexed fragment ({nfr})\")\n\n    # print(f\" ... setting embedding_charges={v}\")\n    return v\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.set_return_total_data","title":"set_return_total_data  <code>classmethod</code>","text":"<pre><code>set_return_total_data(v: Optional[bool], values) -&gt; bool\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@validator(\"return_total_data\", always=True)\n@classmethod\n# v2: def set_return_total_data(cls, v: Optional[bool], info: FieldValidationInfo) -&gt; bool:\ndef set_return_total_data(cls, v: Optional[bool], values) -&gt; bool:\n    # print(f\"hit return_total_data validator with {v}\", end=\"\")\n    if v is not None:\n        rtd = v\n    # v2: elif info.data[\"driver\"] in [\"gradient\", \"hessian\"]:\n    elif values[\"driver\"] in [\"gradient\", \"hessian\"]:\n        rtd = True\n    else:\n        rtd = False\n\n    # v2: if info.data.get(\"embedding_charges\", False) and rtd is False:\n    if values.get(\"embedding_charges\", False) and rtd is False:\n        raise ValueError(\"Cannot return interaction data when using embedding scheme.\")\n\n    # print(f\" ... setting rtd={rtd}\")\n    return rtd\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.set_levels","title":"set_levels  <code>classmethod</code>","text":"<pre><code>set_levels(v: Any, values) -&gt; Dict[Union[int, Literal['supersystem']], str]\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@validator(\"levels\", always=True)\n@classmethod\n# v2: def set_levels(cls, v: Any, info: FieldValidationInfo) -&gt; Dict[Union[int, Literal[\"supersystem\"]], str]:\ndef set_levels(cls, v: Any, values) -&gt; Dict[Union[int, Literal[\"supersystem\"]], str]:\n    # print(f\"hit levels validator with {v}\", end=\"\")\n\n    if v is None:\n        pass\n        # TODO levels = {plan.max_nbody: method}\n        #v = {info.data[\"nfragments\"]: \"???method???\"}\n        #v = {len(info.data[\"molecule\"].fragments): \"???method???\"}\n        # v2: v = {len(info.data[\"molecule\"].fragments): \"(auto)\"}\n        v = {len(values[\"molecule\"].fragments): \"(auto)\"}\n    else:\n        # rearrange bodies in order with supersystem last lest body count fail in organization loop below\n        v = dict(sorted(v.items(), key=lambda item: 1000 if item[0] == \"supersystem\" else item[0]))\n\n    # print(f\" ... setting levels={v}\")\n    return v\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.set_max_nbody","title":"set_max_nbody  <code>classmethod</code>","text":"<pre><code>set_max_nbody(v: Any, values) -&gt; int\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@validator(\"max_nbody\", always=True)\n@classmethod\n# v2: def set_max_nbody(cls, v: Any, info: FieldValidationInfo) -&gt; int:\ndef set_max_nbody(cls, v: Any, values) -&gt; int:\n    # print(f\"hit max_nbody validator with {v}\", end=\"\")\n    # v2: levels_max_nbody = max(nb for nb in info.data[\"levels\"] if nb != \"supersystem\")\n    # v2: nfr = len(info.data[\"molecule\"].fragments)\n    levels_max_nbody = max(nb for nb in values[\"levels\"] if nb != \"supersystem\")\n    nfr = len(values[\"molecule\"].fragments)\n    # print(f\" {levels_max_nbody=} {nfr=}\", end=\"\")\n\n    #ALT if v == -1:\n    if v is None:\n        v = levels_max_nbody\n    elif v &lt; 0 or v &gt; nfr:\n        raise ValueError(f\"max_nbody={v} should be between 1 and {nfr}.\")\n    elif v != levels_max_nbody:\n        #raise ValueError(f\"levels={levels_max_nbody} contradicts user max_nbody={v}.\")\n        # TODO reconsider logic. move this from levels to here?\n        # v2: info.data[\"levels\"] = {v: \"(auto)\"}\n        values[\"levels\"] = {v: \"(auto)\"}\n    else:\n        pass\n        # TODO once was           return min(v, nfragments)\n\n    # print(f\" ... setting max_nbody={v}\")\n    return v\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.set_supersystem_ie_only","title":"set_supersystem_ie_only  <code>classmethod</code>","text":"<pre><code>set_supersystem_ie_only(v: Optional[bool], values) -&gt; bool\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@validator(\"supersystem_ie_only\", always=True)\n@classmethod\n# v2: def set_supersystem_ie_only(cls, v: Optional[bool], info: FieldValidationInfo) -&gt; bool:\ndef set_supersystem_ie_only(cls, v: Optional[bool], values) -&gt; bool:\n    # print(f\"hit supersystem_ie_only validator with {v}\", end=\"\")\n    sio = v\n    # v2: _nfr = len(info.data[\"molecule\"].fragments)\n    _nfr = len(values[\"molecule\"].fragments)\n\n    # v2: _max_nbody = info.data[\"max_nbody\"]\n    # get(..., None) b/c in v1, all fields processed even if max_nbody previously failed\n    _max_nbody = values.get(\"max_nbody\", None)\n    if (sio is True) and (_max_nbody != _nfr):\n        raise ValueError(f\"Cannot skip intermediate n-body jobs when max_nbody={_max_nbody} != nfragments={_nfr}.\")\n\n    if (sio is True) and (\"vmfc\" in values[\"bsse_type\"]):\n        raise ValueError(f\"Cannot skip intermediate n-body jobs when VMFC in bsse_type={values['bsse_type']}. Use CP instead.\")\n\n    # print(f\" ... setting {sio=}\")\n    return sio\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.from_manybodyinput","title":"from_manybodyinput  <code>classmethod</code>","text":"<pre><code>from_manybodyinput(input_model: ManyBodyInput, build_tasks: bool = True)\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>@classmethod\ndef from_manybodyinput(cls, input_model: ManyBodyInput, build_tasks: bool = True):\n\n    computer_model = cls(\n        molecule=input_model.molecule,\n        driver=input_model.specification.driver,\n        # v2: **input_model.specification.keywords.model_dump(exclude_unset=True),\n        **input_model.specification.keywords.dict(exclude_unset=True),\n        input_data=input_model,  # storage, to reconstitute ManyBodyResult\n    )\n    nb_per_mc = computer_model.nbodies_per_mc_level\n\n    # print(\"\\n&lt;&lt;&lt;  (ZZ 1) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben  &gt;&gt;&gt;\")\n    # v2: pprint.pprint(computer_model.model_dump(), width=200)\n    # pprint.pprint(computer_model.dict(), width=200)\n    # print(f\"nbodies_per_mc_level={nb_per_mc}\")\n\n    comp_levels = {}\n    for mc_level_idx, mtd in enumerate(computer_model.levels.values()):\n        for lvl1 in nb_per_mc[mc_level_idx]:\n            key = \"supersystem\" if lvl1 == \"supersystem\" else int(lvl1)\n            comp_levels[key] = mtd\n\n    specifications = {}\n    for mtd, spec in computer_model.input_data.specification.specification.items():\n        spec = spec.dict()\n        specifications[mtd] = {}\n        specifications[mtd][\"program\"] = spec.pop(\"program\")\n        specifications[mtd][\"specification\"] = spec\n        specifications[mtd][\"specification\"][\"driver\"] = computer_model.driver  # overrides atomic driver with mb driver\n        specifications[mtd][\"specification\"].pop(\"schema_name\", None)\n\n    computer_model.qcmb_core = ManyBodyCore(\n        computer_model.molecule,\n        computer_model.bsse_type,\n        comp_levels,\n        return_total_data=computer_model.return_total_data,\n        supersystem_ie_only=computer_model.supersystem_ie_only,\n        embedding_charges=computer_model.embedding_charges,\n    )\n\n    if not build_tasks:\n        return computer_model\n\n    try:\n        import qcengine as qcng\n    except ModuleNotFoundError:\n        raise ModuleNotFoundError(\n            \"Python module qcengine not found. Solve by installing it: \"\n            \"`conda install qcengine -c conda-forge` or `pip install qcengine`\")\n\n    component_properties = {}\n    component_results = {}\n\n    for chem, label, imol in computer_model.qcmb_core.iterate_molecules():\n        inp = AtomicInput(molecule=imol, **specifications[chem][\"specification\"])\n        # inp = AtomicInput(molecule=imol, **specifications[chem][\"specification\"], extras={\"psiapi\": True})  # faster for p4\n\n        if imol.extras.get(\"embedding_charges\"):  # or test on self.embedding_charges ?\n            if specifications[chem][\"program\"] == \"psi4\":\n                charges = imol.extras[\"embedding_charges\"]\n                fkw = inp.keywords.get(\"function_kwargs\", {})\n                fkw.update({\"external_potentials\": charges})\n                inp.keywords[\"function_kwargs\"] = fkw\n            else:\n                raise RuntimeError(f\"Don't know how to handle external charges in {specifications[chem]['program']}\")\n\n        _, real, bas = delabeler(label)\n        result = qcng.compute(inp, specifications[chem][\"program\"])\n        component_results[label] = result\n\n        if not result.success:\n            # print(result.error.error_message)\n            raise RuntimeError(\"Calculation did not succeed! Error:\\n\" + result.error.error_message)\n\n        # pull out stuff\n        props = {\"energy\", \"gradient\", \"hessian\"}\n\n        component_properties[label] = {}\n\n        for p in props:\n            if hasattr(result.properties, f\"return_{p}\"):\n                v = getattr(result.properties, f\"return_{p}\")\n                # print(f\"  {label} {p}: {v}\")\n                if v is not None:\n                    component_properties[label][p] = v\n\n    # print(\"\\n&lt;&lt;&lt;  (ZZ 2) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben component_properties  &gt;&gt;&gt;\")\n    # with np.printoptions(precision=6, suppress=True):\n    #     pprint.pprint(component_properties, width=200)\n\n    analyze_back = computer_model.qcmb_core.analyze(component_properties)\n    analyze_back[\"nbody_number\"] = len(component_properties)\n    # print(\"\\n&lt;&lt;&lt;  (ZZ 3) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben analyze_back  &gt;&gt;&gt;\")\n    # pprint.pprint(analyze_back, width=200)\n\n    return computer_model.get_results(external_results=analyze_back, component_results=component_results)\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.plan","title":"plan","text":"<pre><code>plan()\n</code></pre> Source code in <code>qcmanybody/computer.py</code> <pre><code>def plan(self):\n    # uncalled function\n    return [t.plan() for t in self.task_list.values()]\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.compute","title":"compute","text":"<pre><code>compute(client: Optional[FractalClient] = None) -&gt; None\n</code></pre> <p>Run quantum chemistry.</p> <p>NOTE: client logic removed (compared to psi4.driver.ManyBodyComputer)</p> Source code in <code>qcmanybody/computer.py</code> <pre><code>def compute(self, client: Optional[\"qcportal.FractalClient\"] = None) -&gt; None:\n    \"\"\"Run quantum chemistry.\n\n    NOTE: client logic removed (compared to psi4.driver.ManyBodyComputer)\n    \"\"\"\n    for t in self.task_list.values():\n        t.compute(client=client)\n</code></pre>"},{"location":"api/#qcmanybody.ManyBodyComputer.get_results","title":"get_results","text":"<pre><code>get_results(external_results: Dict, component_results: Dict, client: Optional[FractalClient] = None) -&gt; ManyBodyResult\n</code></pre> <p>Return results as ManyBody-flavored QCSchema.</p> Source code in <code>qcmanybody/computer.py</code> <pre><code>    def get_results(self, external_results: Dict, component_results: Dict, client: Optional[\"qcportal.FractalClient\"] = None) -&gt; ManyBodyResult:\n        \"\"\"Return results as ManyBody-flavored QCSchema.\"\"\"\n\n        ret_energy = external_results.pop(\"ret_energy\")\n        ret_ptype = ret_energy if self.driver == \"energy\" else external_results.pop(f\"ret_{self.driver.name}\")\n        ret_gradient = external_results.pop(\"ret_gradient\", None)\n        nbody_number = external_results.pop(\"nbody_number\")\n        component_properties = external_results.pop(\"component_properties\")\n        stdout = external_results.pop(\"stdout\")\n\n        # load QCVariables\n        qcvars = {\n            'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),\n            'NBODY NUMBER': nbody_number,\n        }\n\n        properties = {\n            \"calcinfo_nmc\": len(self.nbodies_per_mc_level),\n            \"calcinfo_nfr\": self.nfragments,  # or len(self.molecule.fragments)\n            \"calcinfo_natom\": len(self.molecule.symbols),\n            \"calcinfo_nmbe\": nbody_number,\n            \"nuclear_repulsion_energy\": self.molecule.nuclear_repulsion_energy(),\n            \"return_energy\": ret_energy,\n        }\n\n        for k, val in external_results.items():\n            if k == \"results\":\n                k = \"nbody\"\n            qcvars[k] = val\n\n        qcvars['CURRENT ENERGY'] = ret_energy\n        if self.driver == 'gradient':\n            qcvars['CURRENT GRADIENT'] = ret_ptype\n            properties[\"return_gradient\"] = ret_ptype\n        elif self.driver == 'hessian':\n            qcvars['CURRENT GRADIENT'] = ret_gradient\n            qcvars['CURRENT HESSIAN'] = ret_ptype\n            properties[\"return_gradient\"] = ret_gradient\n            properties[\"return_hessian\"] = ret_ptype\n\n#        build_out(qcvars)\n        atprop = build_manybodyproperties(qcvars[\"nbody\"])\n        # print(\"ATPROP\")\n        # v2: pp.pprint(atprop.model_dump())\n        # pp.pprint(atprop.dict())\n\n#        output_data = {\n#            \"schema_version\": 1,\n#            \"molecule\": gamessmol,  # overwrites with outfile Cartesians in case fix_*=F\n#            \"extras\": {**input_model.extras},\n#            \"native_files\": {k: v for k, v in outfiles.items() if v is not None},\n#            \"properties\": atprop,\n\n#####\n#        nbody_model = self.get_results(client=client)\n#        ret = nbody_model.return_result\n#\n#        wfn = core.Wavefunction.build(self.molecule, \"def2-svp\", quiet=True)\n#\n#        # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., \"2\")\n\n        # print(\"QCVARS PRESCREEN\")\n        # pp.pprint(qcvars)\n\n        for qcv, val in qcvars.items():\n            if not isinstance(val, dict):\n                qcvars[qcv] = val\n\n        # v2: component_results = self.model_dump()['task_list']  # TODO when/where include the indiv outputs\n        #?component_results = self.dict()['task_list']  # TODO when/where include the indiv outputs\n#        for k, val in component_results.items():\n#            val['molecule'] = val['molecule'].to_schema(dtype=2)\n\n        # print(\"QCVARS\")\n        # pp.pprint(qcvars)\n\n        nbody_model = ManyBodyResult(\n            **{\n                'input_data': self.input_data,\n                #'molecule': self.molecule,\n                # v2: 'properties': {**atprop.model_dump(), **properties},\n                'properties': {**atprop.dict(), **properties},\n                'component_properties': component_properties,\n                \"component_results\": component_results,\n                'provenance': provenance_stamp(__name__),\n                'extras': {\n                    'qcvars': qcvars,\n                },\n                'return_result': ret_ptype,\n                \"stdout\": stdout,\n                'success': True,\n            })\n\n#        logger.debug('\\nNBODY QCSchema:\\n' + pp.pformat(nbody_model.model_dump()))\n\n        return nbody_model\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v030-2024-mm-dd-unreleased","title":"v0.3.0 / 2024-MM-DD (Unreleased)","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>#28 Intf -- low-level \"core\" interface renamed from    <code>ManyBodyCalculator</code> to <code>ManyBodyCore</code>. The old name will continue to work for a few months. Also, its file changed    from <code>manybody.py</code> to <code>core.py</code> but it was already a top-level import. @loriab</li> <li>#30 Intf -- low-level \"core\" interface now requires named arguments    beyond the first recognizable ones (mol, bsse_type, levels). @loriab</li> </ul>"},{"location":"changelog/#new-features","title":"New Features","text":""},{"location":"changelog/#enhancements","title":"Enhancements","text":"<ul> <li>#28 Intf -- high-level interface is now importable from the top level    module. @loriab</li> <li>#29 Maint -- QCEngine is needed only for the continuous running    function of the high-level interface, so making it an optional dependency. @loriab</li> <li>#30 Intf -- low-level \"core\" interface now accepts a molecule in    partial schema dictionary format rather than requiring a constructed <code>qcelemental.Molecule</code> object. If the molecule    is a single large fragment, an error is thrown. @loriab</li> <li>#30 Docs -- add end-to-end demos in test_examples. @loriab</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/#misc","title":"Misc.","text":""},{"location":"changelog/#must-unmerged","title":"MUST (Unmerged)","text":""},{"location":"changelog/#wip-unmerged","title":"WIP (Unmerged)","text":""},{"location":"changelog/#v021-2024-05-14","title":"v0.2.1 / 2024-05-14","text":""},{"location":"changelog/#enhancements_1","title":"Enhancements","text":"<ul> <li>#27 Intf -- move high-level interface from   <code>qcmb.qcng_computer.ManyBodyComputerQCNG</code> to <code>qcmb.computer.ManyBodyComputer</code>. Suppressed remaining printing. @loriab</li> </ul>"},{"location":"changelog/#v020-2024-05-13","title":"v0.2.0 / 2024-05-13","text":""},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li>#25 Schema -- added a new field <code>ManyBodyResults.component_results</code>   to store subsystem <code>AtomicResult</code>s (or other Result if layered computation). By default this is not stored, but it can   be with <code>ManyBodyInput.protocols.component_results = \"all\"</code>. @loriab</li> <li>#25 Schema -- added <code>GeneralizedOptimizationInput</code> and   <code>GeneralizedOptimizationResult</code> models as temporary extensions of <code>OptimizationInput/Result</code> when the optimizer can   run <code>ManyBodyInput</code>s through QCEngine, not just <code>AtomicInput</code>s. Needs special QCElemental, QCEngine, and OptKing to   work for now. @loriab</li> </ul>"},{"location":"changelog/#enhancements_2","title":"Enhancements","text":"<ul> <li>#22 Intf -- move high-level interface to main directory and remove   unused functions. Most common route into interface is now: <code>qcmb.ManyBodyComputerQCNG.from_manybodyinput</code>. @loriab</li> <li>#25 Schema -- <code>AtomicSpecification.protocols</code> set in   <code>ManyBodySpecification.specification</code> will now be observed. @loriab</li> <li>#26 Schema -- add <code>AtomicSpecification.extras</code>. @loriab</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>#25 Schema -- <code>ManyBodyKeywords.embedding_charges</code> now default to None   rather than empty dict. @loriab</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc.","text":"<ul> <li>#21 Docs -- installation and molecule. @bennybp</li> <li>#24 Intf -- release \"frozen\" pydantic on high-level   ManyBodyComputerQCNG, so core-interface ManyBodyCalculator can live on the class. @loriab</li> <li>#26 Cleanup -- remove most debug printing. @loriab</li> </ul>"},{"location":"changelog/#v010-2024-04-24","title":"v0.1.0 / 2024-04-24","text":""},{"location":"changelog/#new-features_2","title":"New Features","text":"<ul> <li>Runs CP, NoCP, VMFC energies, gradients, and Hessians. @bennybp @loriab</li> </ul>"},{"location":"core-interface/","title":"Core Interface","text":"<p>The core interface of QCManyBody is designed to allow for more flexibility in how the calculations are run. The primary responsibilities of the core interface are:</p> <ol> <li>Given a molecule and desired levels of MBE, return the fragments and levels that must be computed for each fragment</li> <li>Given a dictionary of the results of those computations, analyze those results and calculate the desired manybody properties</li> </ol> <p>Note that the user is expected to run the calculations themselves, and the core interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#using-the-core-interface","title":"Using the core interface","text":"<p>The core interface is accessed through the <code>ManyBodyCore</code> class.</p> <p>The first step is to create a molecule. This molecule is a QCElemental molecule object, and must contain fragments. (see also: moleule input)</p> <pre><code>from qcelemental.models import Molecule\n\n# Create a molecule with 3 neon atoms, each as its own fragment\n\nmol = Molecule(symbols=[\"ne\", \"ne\", \"ne\"],\n               geometry=[[0,0,0], [0,0,2], [0,0,4]],\n               fragments=[[0], [1], [2]])\n</code></pre> <p>Next, create a <code>ManyBodyCore</code> object. This object is constructed using the molecule, the desired BSSE correction, levels of MBE, and other options of the MBE.</p> <pre><code>from qcmanybody import ManyBodyCore\n\nmbc = ManyBodyCore(molecule=mol,\n                   bsse_type=[\"cp\"],\n                   levels={1: \"ccsd/cc-pvtz\",\n                           2: \"mp2/cc-pvdz\",\n                           3: \"mp2/cc-pvdz\"},\n                   return_total_data: True,\n                   supersystem_ie_only: False,\n                   embedding_charges: None)\n</code></pre> <p>The <code>levels</code> option is a dictionary that specifies the n-body level as a key, then an arbitrary string as the description of the calculation to be performed at the n-body level. This string is termed the 'model chemistry' is completely arbitrary; it only has meaning to the user, and the user is expected to map these strings to some meaningful definition of a calculation.</p> <p>Note: The core interface is less flexible than the high-level interface when it comes to the <code>levels</code> option.     In the core interface, all levels must be accounted for (that is, keys must go from 1 to the maximum     nbody you would like to calculate). All levels must be present even if the model chemistry     is the same for all levels.</p> <p>For a complete discussion of the other options available in the <code>ManyBodyCore</code> object, see the keywords discussion the <code>ManyBodyCore API documentation</code>.</p> <p>The next step is to obtain the calculations to be run from the <code>ManyBodyCore</code> object. This is done with a python generator function <code>iterate_molecules</code> that returns a tuple. This tuple contains</p> <ol> <li>The string describing the calculation to be run (the model chemistry string, as defined in the <code>levels</code> dictionary)</li> <li>A label for the calculation. This label is opaque to the user but used to identify the calculation when analyzing the results.</li> <li>A <code>Molecule</code> object that contains the cluster of fragments to be computed.</li> </ol> <pre><code>calculation_results = {}\nfor model_chemistry, label, mol_cluster in mbc.iterate_molecules():\n    calculation_results[label] = run_calculation(mol_cluster, model_chemistry)\n</code></pre> <p>Note that it is entirely up to the user to run the calculation somehow - this level of interface does not provide any tools for running the calculations.</p>"},{"location":"core-interface/#results-dictionary","title":"Results dictionary","text":"<p>The data returned from the calculations is expected to be stored in a nested dictionary. The level is the opaque label as given from the <code>QCManyBodyCore</code>. The second level is the name of the property.</p> <pre><code>calculation_results = {\n    'label1': {\n        'energy': -1.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]],\n    },\n    'label2': {\n        'energy': -2.0,\n        'gradient': [[4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n    'label3': {\n        'energy': -3.0,\n        'gradient': [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    },\n}\n</code></pre>"},{"location":"core-interface/#analysis","title":"Analysis","text":"<p>This result dictionary is all that is needed to perform the final analysis and calculation of the MBE properties.</p> <pre><code>final_results = mbc.analyze(calculation_results)\n</code></pre> <p>For a discussion about what the results contain, see the results documentation.</p>"},{"location":"high-level-interface/","title":"High-Level Interface","text":""},{"location":"keywords/","title":"Keywords and options","text":""},{"location":"keywords/#required","title":"Required","text":""},{"location":"keywords/#molecule","title":"Molecule","text":"<p>The molecule used by QCManyBody is a QCElemental Molecule object. The only requirement for use in QCManyBody is that the molecule has multiple fragments. It is these fragments that will be used in the many-body expansion.</p> <p>Examples:</p> <pre><code>from qcelemental.models import Molecule\n\n# Molecule with 3 neon atoms, each as its own fragment\nne3 = Molecule(symbols=[\"ne\", \"ne\", \"ne\"],\n               geometry=[[0,0,0],[0,0,2],[0,0,4]],\n               fragments=[[0], [1], [2]])\n\n# Water tetramer\nwater4 = Molecule(symbols=['o', 'h', 'h', 'o', 'h', 'h', 'o', 'h', 'h', 'o', 'h', 'h'],\n                  geometry=[[-2.8, -1.2, -0.2], [-1.1, -2.1, -0.0], [-3.8, -2.1,  1.1],\n                            [-2.8, -1.2, -2.2], [-1.1, -2.1, -2.0], [-3.8, -2.1, -1.1],\n                            [-2.8, -1.2, -4.2], [-1.1, -2.1, -4.0], [-3.8, -2.1, -3.1],\n                            [-2.8, -1.2, -6.2], [-1.1, -2.1, -6.0], [-3.8, -2.1, -5.1]],\n                          fragments=[[0,1,2], [3,4,5], [6,7,8], [9,10,11]])\n\n# Water trimer, using the from_data function\n# the -- is used to separate fragments\nwater3 = Molecule.from_data(\n\"\"\"\nO      -2.76373224  -1.24377706  -0.15444566\nH      -1.12357791  -2.06227970  -0.05243799\nH      -3.80792362  -2.08705525   1.06090407\n--\nO       2.46924614  -1.75437739  -0.17092884\nH       3.76368260  -2.21425403   1.00846104\nH       2.30598330   0.07098445  -0.03942473\n--\nO       0.29127930   3.00875625   0.20308515\nH      -1.21253048   1.95820900   0.10303324\nH       0.10002049   4.24958115  -1.10222079\nunits bohr\n\"\"\"\n)\n</code></pre>"},{"location":"keywords/#bsse_type","title":"bsse_type","text":"<p>The <code>bsse_type</code> parameter specifies the type of correction for basis set superposition error (BSSE). Multiple types can be specified, in which case the results will include separate fields for each type of correction.</p> <p>Valid types are:</p> <ul> <li><code>nocp</code> - No counterpoise or other corrections applied</li> <li><code>cp</code> - Counterpoise correction</li> <li><code>vmfc</code> - Valiron-Mayer function counterpoise correction</li> </ul>"},{"location":"keywords/#levels-and-max_nbody","title":"levels and max_nbody","text":"<p>Dictionary of different levels of theory for different levels of expansion. The keys are integers or \"supersystem\", and the values are arbitrary strings that represent the model chemistry or level of theory to use for that level. This string is arbitrary and only has meaning to the user - the user is expected to map these strings to some meaningful definition of a calculation.</p> <p>If a <code>supersystem</code> key is present, all higher order n-body effects up to <code>max_nbody</code> will be computed.</p> <p>In the core interface, all levels must be accounted for (that is, keys must go from 1 to the maximum), and <code>max_nbody</code> cannot be specified. In the high-level interface, a computational model fills in for any lower unlisted n-body levels.</p> <p>In the high-level interface, if both levels and max_nbody are provided, they must be consistent. </p> <p>Examples:</p> <ul> <li><code>{2: 'ccsd(t)/cc-pvdz', 3: 'mp2'}</code></li> <li><code>max_nbody=3</code> and <code>levels={1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}</code></li> </ul>"},{"location":"keywords/#keywords-and-options_1","title":"Keywords and Options","text":""},{"location":"keywords/#return_total_data","title":"return_total_data","text":"<p>When set to true, the manybody calculation will return the total data (energy/gradient/hessian/property) of the system. If not, the return will only contain interaction data.</p> <p>Note that the calculation of counterpoise corrected total properties implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than. For some properties such as gradients and hessians, <code>return_total_data = False</code> is rarely useful.</p>"},{"location":"keywords/#supersystem_ie_only","title":"supersystem_ie_only","text":"<p>Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When false, each n-body level in the MBE up through <code>max_nbody</code> will be computed. When true (only allowed for <code>max_nbody = nfragments</code>), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body.</p> <p>When true, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code>; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers).</p> <p>This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code> Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings.</p>"},{"location":"qcschema/","title":"QCSchema","text":"<p>ManyBodyKeywords</p> key type required description default bsse_type False Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. [] embedding_charges typing.List[float] False Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. None return_total_data False When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of counterpoise corrected total energies implies the calculation of the energies of monomers in the monomer basis, hence specifying <code>return_total_data = True</code> may carry out more computations than <code>return_total_data = False</code>. For gradients and Hessians, <code>return_total_data = False</code> is rarely useful. None levels False Dictionary of different levels of theory for different levels of expansion. Note that the primary method_string is not used when this keyword is given. <code>supersystem</code> computes all higher order n-body effects up to the number of fragments; this higher-order correction uses the nocp basis, regardless of bsse_type. A method fills in for any lower unlisted nbody levels. Note that if both this and max_nbody are provided, they must be consistent. Examples: SUPERSYSTEM definition suspect* {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} * {2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} * Now invalid: {1: 2, 2: 'ccsd(t)/cc-pvdz', 3: 'mp2'} None max_nbody False Maximum number of bodies to include in the many-body treatment. Possible: max_nbody &lt;= nfragments. Default: max_nbody = nfragments. None supersystem_ie_only False Target the supersystem total/interaction energy (IE) data over the many-body expansion (MBE) analysis, thereby omitting intermediate-body calculations. When False (default), compute each n-body level in the MBE up through <code>max_nbody</code>. When True (only allowed for <code>max_nbody = nfragments</code> ), only compute enough for the overall interaction/total energy: max_nbody-body and 1-body. When True, properties <code>INTERACTION {driver} THROUGH {max_nbody}-BODY</code> will always be available; <code>TOTAL {driver} THROUGH {max_nbody}-BODY</code> will be available depending on <code>return_total_data</code> ; and <code>{max_nbody}-BODY CONTRIBUTION TO {driver}</code> won't be available (except for dimers). This keyword produces no savings for a two-fragment molecule. But for the interaction energy of a three-fragment molecule, for example, 2-body subsystems can be skipped with <code>supersystem_ie_only=True</code>. Do not use with <code>vmfc</code> in <code>bsse_type</code> as it cannot produce savings. False <p>ManyBodySpecification</p> key type required description default schema_name typing.Literal['qcschema_manybodyspecification'] False qcschema_manybodyspecification keywords True The many-body-specific keywords for user control. None protocols False Protocols regarding the manipulation of a ManyBody output data. ManyBodyProtocols(component_results=) driver True The computation driver; i.e., energy, gradient, hessian. None specification True ??? TODO expand to cbs, fd None <p>ManyBodyInput</p> key type required description default schema_name typing.Literal['qcschema_manybodyinput'] False qcschema_manybodyinput specification True ??? None molecule True Target molecule for many-body expansion (MBE) or interaction energy (IE) analysis. None extras typing.Any False Additional information to bundle with the computation. Use for schema development and scratch space. {} <p>Note</p> <p>The properties model is generated dynamically based on a constant <code>MAX_NBODY</code>. To not overload the docs table, this is set to 5, which covers full calculations on tetramers. To use a larger <code>ManyBodyKeywords.max_nbody</code>, reset this value.</p> <pre><code>import qcmanybody as qcmb\nqcmb.models.MAX_NBODY = 8\n</code></pre> <p>ManyBodyResultProperties</p> key type required description default calcinfo_nmc False The number of model chemistries applied to n-body levels of the computation. None calcinfo_nfr False The number of fragments in the molecule for the computation. None calcinfo_natom False The number of atoms in the computation. None calcinfo_nmbe False The number of real/ghost molecule patterns for the computation. None nuclear_repulsion_energy False The nuclear repulsion energy. None return_energy False The interaction energy of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Always available. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.energy</code> computations. None return_gradient False The interaction gradient of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Available when driver is g/h. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.gradient</code> computations. None return_hessian False The interaction Hessian of the requested method: IE or total (depending on return_total_data) with cp/nocp/vmfc treatment (dep. on first of bsse_type). Available when driver is h. Identical to :attr:<code>~qcelemental.models.ManyBodyResult.return_result</code> for :attr:<code>~qcelemental.models.AtomicInput.driver</code>\\ =\\ :attr:<code>~qcelemental.models.DriverEnum.hessian</code> computations. None cp_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1. None cp_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2. None cp_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3. None cp_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4. None cp_corrected_total_energy False Best available total energy with cp treatment: cp_corrected_total_energy_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T. None cp_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None cp_corrected_interaction_energy False Best available interaction energy with cp treatment: cp_corrected_interaction_energy_through_{max_nbody}_body. Available when cp in bsse_type. None cp_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2. None cp_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3. None cp_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body data for partial IE; inputs are total energies w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4. None nocp_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1. None nocp_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2. None nocp_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3. None nocp_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4. None nocp_corrected_total_energy False Best available total energy without cp treatment: nocp_corrected_total_energy_through_{max_nbody}_body. Available when nocp in bsse_type. None nocp_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None nocp_corrected_interaction_energy False Best available interaction energy without cp treatment: nocp_corrected_interaction_energy_through_{max_nbody}_body. Available when nocp in bsse_type. None nocp_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2. None nocp_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3. None nocp_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body data for partial IE; inputs are total energies w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4. None vmfc_corrected_total_energy_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1. None vmfc_corrected_total_energy_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2. None vmfc_corrected_total_energy_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3. None vmfc_corrected_total_energy_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total energies with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4. None vmfc_corrected_total_energy False Best available total energy with vmfc treatment: vmfc_corrected_total_energy_through_{max_nbody}_body. Available when vmfc in bsse_type. None vmfc_corrected_interaction_energy_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_energy False Best available interaction energy with vmfc treatment: vmfc_corrected_interaction_energy_through_{max_nbody}_body. Available when vmfc in bsse_type. None vmfc_corrected_2_body_contribution_to_energy False 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2. None vmfc_corrected_3_body_contribution_to_energy False 3-body total data less (3-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3. None vmfc_corrected_4_body_contribution_to_energy False 4-body total data less (4-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4. None cp_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1 &amp; driver is g/h. None cp_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2 &amp; driver is g/h. None cp_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3 &amp; driver is g/h. None cp_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4 &amp; driver is g/h. None cp_corrected_total_gradient False Best available total gradient with cp treatment: cp_corrected_total_gradient_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T &amp; driver is g/h. None cp_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None cp_corrected_interaction_gradient False Best available interaction gradient with cp treatment: cp_corrected_interaction_gradient_through_{max_nbody}_body. Available when cp in bsse_type &amp; driver is g/h. None cp_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None cp_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None cp_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body data for partial IE; inputs are total gradients w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None nocp_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. None nocp_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None nocp_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None nocp_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None nocp_corrected_total_gradient False Best available total gradient without cp treatment: nocp_corrected_total_gradient_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is g/h. None nocp_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_gradient False Best available interaction gradient without cp treatment: nocp_corrected_interaction_gradient_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is g/h. None nocp_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None nocp_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None nocp_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body data for partial IE; inputs are total gradients w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None vmfc_corrected_total_gradient_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total gradients with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None vmfc_corrected_total_gradient False Best available total gradient with vmfc treatment: vmfc_corrected_total_gradient_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is g/h. None vmfc_corrected_interaction_gradient_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total gradients w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_gradient False Best available interaction gradient with vmfc treatment: vmfc_corrected_interaction_gradient_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is g/h. None vmfc_corrected_2_body_contribution_to_gradient False 2-body total data less (2-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is g/h. None vmfc_corrected_3_body_contribution_to_gradient False 3-body total data less (3-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is g/h. None vmfc_corrected_4_body_contribution_to_gradient False 4-body total data less (4-1)-body total data for partial IE; inputs are total gradients w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is g/h. None cp_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=1 &amp; driver is h. None cp_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=2 &amp; driver is h. None cp_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=3 &amp; driver is h. None cp_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians w/ cp treatment. Available when cp in bsse_type &amp; rtd=T &amp; max_nbody&gt;=4 &amp; driver is h. None cp_corrected_total_hessian False Best available total Hessian with cp treatment: cp_corrected_total_hessian_through_{max_nbody}_body. Available when cp in bsse_type &amp; rtd=T &amp; driver is h. None cp_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians with cp treatment. Available when when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None cp_corrected_interaction_hessian False Best available interaction Hessian with cp treatment: cp_corrected_interaction_hessian_through_{max_nbody}_body. Available when cp in bsse_type &amp; driver is h. None cp_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None cp_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None cp_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body data for partial IE; inputs are total Hessians w/ cp treat. Available when cp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None nocp_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. None nocp_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None nocp_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None nocp_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians without cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None nocp_corrected_total_hessian False Best available total Hessian without cp treatment: nocp_corrected_total_hessian_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is h. None nocp_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians without cp treatment. Available when when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None nocp_corrected_interaction_hessian False Best available interaction Hessian without cp treatment: nocp_corrected_interaction_hessian_through_{max_nbody}_body. Available when nocp in bsse_type &amp; driver is h. None nocp_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None nocp_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None nocp_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body data for partial IE; inputs are total Hessians w/o cp treatment. Available when nocp in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None vmfc_corrected_total_hessian_through_1_body False MBE sum of subsystems of 1-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. None vmfc_corrected_total_hessian_through_2_body False MBE sum of subsystems of 2-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None vmfc_corrected_total_hessian_through_3_body False MBE sum of subsystems of 3-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None vmfc_corrected_total_hessian_through_4_body False MBE sum of subsystems of 4-body or fewer (cumulative); summed are total Hessians with vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None vmfc_corrected_total_hessian False Best available total Hessian with vmfc treatment: vmfc_corrected_total_hessian_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is h. None vmfc_corrected_interaction_hessian_through_1_body False 1-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=1 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_2_body False 2-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_3_body False 3-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian_through_4_body False 4-body total data less 1-body total data for cumulative IE; inputs are total Hessians w/ vmfc treatment. Available when when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. The 1-body quantity is zero by definition. None vmfc_corrected_interaction_hessian False Best available interaction Hessian with vmfc treatment: vmfc_corrected_interaction_hessian_through_{max_nbody}_body. Available when vmfc in bsse_type &amp; driver is h. None vmfc_corrected_2_body_contribution_to_hessian False 2-body total data less (2-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=2 &amp; driver is h. None vmfc_corrected_3_body_contribution_to_hessian False 3-body total data less (3-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=3 &amp; driver is h. None vmfc_corrected_4_body_contribution_to_hessian False 4-body total data less (4-1)-body total data for partial IE; inputs are total Hessians w/ vmfc treatment. Available when vmfc in bsse_type &amp; max_nbody&gt;=4 &amp; driver is h. None <p>ManyBodyResult</p> key type required description default input_data True None success typing.Literal[True] False Always <code>True</code> for a successful result True stdout False The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. None stderr False The standard error of the program execution. None schema_name typing.Literal['qcschema_manybodyresult'] False qcschema_manybodyresult schema_version typing.Literal[1] False The version number of <code>schema_name</code> to which this model conforms. 1 id False The optional ID for the object. None extras typing.Any False Additional information to bundle with the object. Use for schema development and scratch space. {} provenance True Provenance information. None properties True None None component_properties True The key results for each subsystem species computed. Keys contain modelchem, real and ghost information (e.g., <code>'[\"(auto)\", [2], [1, 2, 3]]'</code>). Values are total e/g/H/property results. Array values, if present, are sized and shaped for the full supersystem. None component_results False Detailed results {} return_result typing.Union[float, qcelemental.models.types.Array, typing.Dict[str, typing.Any]] True The primary return specified by the :attr:<code>~qcelemental.models.AtomicInput.driver</code> field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. None"},{"location":"qcschema/#qcmanybody.models.BsseEnum","title":"qcmanybody.models.BsseEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available basis-set superposition error (BSSE) treatments.</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyKeywords","title":"qcmanybody.models.ManyBodyKeywords","text":"<p>               Bases: <code>ProtoModel</code></p> <p>The many-body-specific keywords for user control.</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodySpecification","title":"qcmanybody.models.ManyBodySpecification","text":"<p>               Bases: <code>ProtoModel</code></p> <p>Combining the what (ManyBodyKeywords) with the how (AtomicSpecification).</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyInput","title":"qcmanybody.models.ManyBodyInput","text":"<p>               Bases: <code>ProtoModel</code></p> <p>Combining the what and how (ManyBodySpecification) with the who (Molecule).</p>"},{"location":"qcschema/#qcmanybody.models.ManyBodyResultProperties","title":"qcmanybody.models.ManyBodyResultProperties  <code>module-attribute</code>","text":"<pre><code>ManyBodyResultProperties = ProtoModelSkipDefaults\n</code></pre>"},{"location":"qcschema/#qcmanybody.models.ManyBodyResult","title":"qcmanybody.models.ManyBodyResult","text":"<p>               Bases: <code>SuccessfulResultBase</code></p>"},{"location":"results/","title":"Results","text":"<p>The QCManyBody package outputs many results from its analysis.</p> <p>For the core interface, the results are expected to be stored in a nested dictionary. For the high-level interface, the results are stored in a <code>ManyBodyResult</code> object.</p>"},{"location":"results/#fields","title":"Fields","text":""}]}