

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qcmanybody.computer &mdash; QCManyBody 0.1.dev1+g16cf35718 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../_static/autodoc_pydantic.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=46835a7a"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/version-switcher.js?v=55f02482"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            QCManyBody
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../high-level-interface.html">High-Level Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-interface.html">Core Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qcschema.html">QCSchema</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">QCManyBody API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../keywords.html">Keywords and Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../results.html">Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QCManyBody</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qcmanybody.computer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qcmanybody.computer</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>

<span class="c1"># printing and logging formatting niceties</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pprint</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">pp</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">PrettyPrinter</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">nppp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_str</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">nppp10</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_str</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">ast</span><span class="w"> </span><span class="kn">import</span> <span class="n">literal_eval</span>

<span class="c1"># v2: from typing import TYPE_CHECKING, Any, ClassVar, Dict, List, Tuple, Union, Literal, Optional</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># v2: from pydantic import ConfigDict, field_validator, FieldValidationInfo, computed_field, BaseModel, Field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydantic.v1</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span><span class="p">,</span> <span class="n">create_model</span><span class="p">,</span> <span class="n">validator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qcelemental.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">AtomicInput</span><span class="p">,</span> <span class="n">AtomicResult</span><span class="p">,</span> <span class="n">DriverEnum</span><span class="p">,</span> <span class="n">FailedOperation</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">,</span> <span class="n">ProtoModel</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">qcmanybody</span><span class="w"> </span><span class="kn">import</span> <span class="n">ManyBodyCore</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qcmanybody.models.v1</span><span class="w"> </span><span class="kn">import</span> <span class="n">BsseEnum</span><span class="p">,</span> <span class="n">ManyBodyInput</span><span class="p">,</span> <span class="n">ManyBodyKeywords</span><span class="p">,</span> <span class="n">ManyBodyResult</span><span class="p">,</span> <span class="n">ManyBodyResultProperties</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qcmanybody.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">delabeler</span><span class="p">,</span> <span class="n">provenance_stamp</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">qcportal</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ManyBodyComputer&quot;</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BaseComputerQCNG</span><span class="p">(</span><span class="n">ProtoModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for &quot;computers&quot; that plan, run, and process QC tasks.&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># TODO can remove?</span>
    <span class="c1">#</span>
    <span class="c1"># v2: model_config = ConfigDict(</span>
    <span class="c1"># v2:     extra=&quot;allow&quot;,</span>
    <span class="c1"># v2:     frozen=False,</span>
    <span class="c1"># v2: )</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Config</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s2">&quot;allow&quot;</span>
        <span class="c1"># v2: frozen = False</span>
        <span class="n">allow_mutation</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AtomicComputer</span><span class="p">(</span><span class="n">BaseComputerQCNG</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computer for analytic single-geometry computations.&quot;&quot;&quot;</span>

    <span class="n">molecule</span><span class="p">:</span> <span class="n">Molecule</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The molecule to use in the computation.&quot;</span><span class="p">)</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).&quot;</span><span class="p">)</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).&quot;</span><span class="p">)</span>
    <span class="n">driver</span><span class="p">:</span> <span class="n">DriverEnum</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The resulting type of computation: energy, gradient, hessian, properties.&quot;</span>
        <span class="s2">&quot;Note for finite difference that this should be the target driver, not the means driver.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">keywords</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The keywords to use in the computation.&quot;</span><span class="p">)</span>
    <span class="n">program</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Which program harness to run single-point with.&quot;</span><span class="p">)</span>
    <span class="n">computed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Whether quantum chemistry has been run on this task.&quot;</span><span class="p">)</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;:py:class:`~qcelemental.models.AtomicResult` return.&quot;</span><span class="p">)</span>
    <span class="n">result_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The optional ID for the computation.&quot;</span><span class="p">)</span>

    <span class="c1"># v2: @field_validator(&quot;basis&quot;)</span>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;basis&quot;</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_basis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># v2: @field_validator(&quot;method&quot;)</span>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># v2: @field_validator(&quot;keywords&quot;)</span>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;keywords&quot;</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_keywords</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">keywords</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plan</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AtomicInput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Form QCSchema input from member data.&quot;&quot;&quot;</span>

        <span class="n">atomic_model</span> <span class="o">=</span> <span class="n">AtomicInput</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="s2">&quot;molecule&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
                <span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                <span class="s2">&quot;model&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;basis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">},</span>
                <span class="s2">&quot;keywords&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">atomic_model</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.client.PortalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run quantum chemistry single-point.</span>

<span class="sd">        NOTE: client logic removed (compared to psi4.driver.AtomicComputer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">qcengine</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute</span> <span class="k">as</span> <span class="n">qcng_compute</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># logger.info(f&#39;&lt;&lt;&lt; JSON launch ... {self.molecule.name} {self.molecule.nuclear_repulsion_energy()}&#39;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">qcng_compute</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="p">,</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># True,</span>
            <span class="c1"># task_config=task_config,</span>
        <span class="p">)</span>

        <span class="c1"># pp.pprint(self.result.model_dump())</span>
        <span class="c1"># logger.debug(pp.pformat(self.result.model_dump()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">computed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.client.PortalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AtomicResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return results as Atomic-flavored QCSchema.</span>

<span class="sd">        NOTE: client removed (compared to psi4.driver.AtomicComputer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>


<div class="viewcode-block" id="ManyBodyComputer">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ManyBodyComputer</span><span class="p">(</span><span class="n">BaseComputerQCNG</span><span class="p">):</span>

    <span class="n">input_data</span><span class="p">:</span> <span class="n">ManyBodyInput</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Input schema containing the relevant settings for performing the many body &quot;</span>
        <span class="s2">&quot;expansion. This is entirely redundant with the piecemeal assembly of this Computer class &quot;</span>
        <span class="s2">&quot;and is only stored to be available for error handling and exact reconstruction of ManyBodyResult.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">bsse_type</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">BsseEnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="p">[</span><span class="n">BsseEnum</span><span class="o">.</span><span class="n">cp</span><span class="p">],</span>
        <span class="c1"># v2: description=ManyBodyKeywords.model_fields[&quot;bsse_type&quot;].description,</span>
        <span class="n">description</span><span class="o">=</span><span class="n">ManyBodyKeywords</span><span class="o">.</span><span class="n">__fields__</span><span class="p">[</span><span class="s2">&quot;bsse_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">field_info</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">molecule</span><span class="p">:</span> <span class="n">Molecule</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Target molecule for many body expansion (MBE) or interaction energy (IE) analysis. &quot;</span>
        <span class="s2">&quot;Fragmentation should already be defined in `fragments` and related fields.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">driver</span><span class="p">:</span> <span class="n">DriverEnum</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The computation driver; i.e., energy, gradient, hessian. In case of ambiguity (e.g., MBE gradient &quot;</span>
        <span class="s2">&quot;through finite difference energies or MBE energy through composite method), this field refers to the &quot;</span>
        <span class="s2">&quot;*target* derivative, not any *means* specification.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">embedding_charges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Atom-centered point charges to be used to speed up nbody-level convergence. Charges are placed on &quot;</span>
        <span class="s2">&quot;molecule fragments whose basis sets are not included in the computation. (An implication is that charges aren&#39;t &quot;</span>
        <span class="s2">&quot;invoked for bsse_type=cp.) Keys: 1-based index of fragment. Values: list of atom charges for that fragment.&quot;</span><span class="p">,</span>
        <span class="c1"># TODO: enforce point charge sum == fragment_charges val</span>
        <span class="n">json_schema_extra</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;nfr&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;varies: nat in ifr&gt;&quot;</span><span class="p">],</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="n">return_total_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># after driver, embedding_charges</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># v2: description=ManyBodyKeywords.model_fields[&quot;return_total_data&quot;].description,</span>
        <span class="n">description</span><span class="o">=</span><span class="n">ManyBodyKeywords</span><span class="o">.</span><span class="n">__fields__</span><span class="p">[</span><span class="s2">&quot;return_total_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">field_info</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">levels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;supersystem&quot;</span><span class="p">]],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># v2: description=ManyBodyKeywords.model_fields[&quot;levels&quot;].description + \</span>
        <span class="n">description</span><span class="o">=</span><span class="n">ManyBodyKeywords</span><span class="o">.</span><span class="n">__fields__</span><span class="p">[</span><span class="s2">&quot;levels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">field_info</span><span class="o">.</span><span class="n">description</span>
        <span class="o">+</span> <span class="s2">&quot;Examples above are processed in the ManyBodyComputer, and once processed, only the values should be used. &quot;</span>
        <span class="s2">&quot;The keys turn into nbodies_per_mc_level, as notated below. &quot;</span>
        <span class="s2">&quot;* {1: &#39;ccsd(t)&#39;, 2: &#39;mp2&#39;, &#39;supersystem&#39;: &#39;scf&#39;} -&gt; nbodies_per_mc_level=[[1], [2], [&#39;supersystem&#39;]] &quot;</span>
        <span class="s2">&quot;* {2: &#39;ccsd(t)/cc-pvdz&#39;, 3: &#39;mp2&#39;} -&gt; nbodies_per_mc_level=[[1, 2], [3]] &quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">max_nbody</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># v2: description=ManyBodyKeywords.model_fields[&quot;max_nbody&quot;].description,</span>
        <span class="n">description</span><span class="o">=</span><span class="n">ManyBodyKeywords</span><span class="o">.</span><span class="n">__fields__</span><span class="p">[</span><span class="s2">&quot;max_nbody&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">field_info</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">supersystem_ie_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># after max_nbody</span>
        <span class="kc">False</span><span class="p">,</span>
        <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># v2: description=ManyBodyKeywords.model_fields[&quot;supersystem_ie_only&quot;].description,</span>
        <span class="n">description</span><span class="o">=</span><span class="n">ManyBodyKeywords</span><span class="o">.</span><span class="n">__fields__</span><span class="p">[</span><span class="s2">&quot;supersystem_ie_only&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">field_info</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">task_list</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># MBETaskComputers] = {}</span>
    <span class="n">qcmb_core</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Low-level interface&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># TODO @computed_field(description=&quot;Number of distinct fragments comprising full molecular supersystem.&quot;)</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nfragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span>

    <span class="c1"># v2: @field_validator(&quot;bsse_type&quot;, mode=&quot;before&quot;)</span>
<div class="viewcode-block" id="ManyBodyComputer.set_bsse_type">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.set_bsse_type">[docs]</a>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;bsse_type&quot;</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_bsse_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">BsseEnum</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="c1"># emulate ordered set</span>
        <span class="c1"># * bt.lower() as return (w/i `list(dict.fromkeys([bt.lower() ...`)</span>
        <span class="c1">#   works until aliases added to BsseEnum</span>
        <span class="c1"># * BsseEnum[bt].value as return works for good vals, but passing bad</span>
        <span class="c1">#   vals through as bt lets pydantic raise a clearer error message</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">BsseEnum</span><span class="p">[</span><span class="n">bt</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">bt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">BsseEnum</span><span class="o">.</span><span class="n">__members__</span> <span class="k">else</span> <span class="n">bt</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">bt</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


    <span class="c1"># v2: @field_validator(&quot;embedding_charges&quot;)</span>
<div class="viewcode-block" id="ManyBodyComputer.set_embedding_charges">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.set_embedding_charges">[docs]</a>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;embedding_charges&quot;</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="c1"># v2: def set_embedding_charges(cls, v: Any, info: FieldValidationInfo) -&gt; Dict[int, List[float]]:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_embedding_charges</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>  <span class="c1"># -&gt; Dict[int, List[float]]:</span>
        <span class="c1"># print(f&quot;hit embedding_charges validator with {v}&quot;, end=&quot;&quot;)</span>
        <span class="n">nfr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span>
        <span class="c1"># v2: if len(v) != info.data[&quot;nfragments&quot;]:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nfr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;embedding_charges dict should have entries for each 1-indexed fragment (</span><span class="si">{</span><span class="n">nfr</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># print(f&quot; ... setting embedding_charges={v}&quot;)</span>
        <span class="k">return</span> <span class="n">v</span></div>


    <span class="c1"># v2: @field_validator(&quot;return_total_data&quot;)</span>
<div class="viewcode-block" id="ManyBodyComputer.set_return_total_data">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.set_return_total_data">[docs]</a>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;return_total_data&quot;</span><span class="p">,</span> <span class="n">always</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="c1"># v2: def set_return_total_data(cls, v: Optional[bool], info: FieldValidationInfo) -&gt; bool:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_return_total_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># print(f&quot;hit return_total_data validator with {v}&quot;, end=&quot;&quot;)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rtd</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1"># v2: elif info.data[&quot;driver&quot;] in [&quot;gradient&quot;, &quot;hessian&quot;]:</span>
        <span class="k">elif</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;hessian&quot;</span><span class="p">]:</span>
            <span class="n">rtd</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rtd</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># v2: if info.data.get(&quot;embedding_charges&quot;, False) and rtd is False:</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;embedding_charges&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="n">rtd</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot return interaction data when using embedding scheme.&quot;</span><span class="p">)</span>

        <span class="c1"># print(f&quot; ... setting rtd={rtd}&quot;)</span>
        <span class="k">return</span> <span class="n">rtd</span></div>


    <span class="c1"># v2: @field_validator(&quot;levels&quot;)</span>
<div class="viewcode-block" id="ManyBodyComputer.set_levels">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.set_levels">[docs]</a>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;levels&quot;</span><span class="p">,</span> <span class="n">always</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="c1"># v2: def set_levels(cls, v: Any, info: FieldValidationInfo) -&gt; Dict[Union[int, Literal[&quot;supersystem&quot;]], str]:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_levels</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;supersystem&quot;</span><span class="p">]],</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="c1"># print(f&quot;hit levels validator with {v}&quot;, end=&quot;&quot;)</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># TODO levels = {plan.max_nbody: method}</span>
            <span class="c1"># v = {info.data[&quot;nfragments&quot;]: &quot;???method???&quot;}</span>
            <span class="c1"># v = {len(info.data[&quot;molecule&quot;].fragments): &quot;???method???&quot;}</span>
            <span class="c1"># v2: v = {len(info.data[&quot;molecule&quot;].fragments): &quot;(auto)&quot;}</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fragments</span><span class="p">):</span> <span class="s2">&quot;(auto)&quot;</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># rearrange bodies in order with supersystem last lest body count fail in organization loop below</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="mi">1000</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;supersystem&quot;</span> <span class="k">else</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># print(f&quot; ... setting levels={v}&quot;)</span>
        <span class="k">return</span> <span class="n">v</span></div>


    <span class="c1"># TODO @computed_field(</span>
    <span class="c1"># TODO     description=&quot;Distribution of active n-body levels among model chemistry levels. All bodies in range &quot;</span>
    <span class="c1"># TODO         &quot;[1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different &quot;</span>
    <span class="c1"># TODO         &quot;modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., &quot;</span>
    <span class="c1"># TODO         &quot;`[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; &quot;</span>
    <span class="c1"># TODO         &quot;`[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. &quot;</span>
    <span class="c1"># TODO         &quot;An entry &#39;supersystem&#39; means all higher order n-body effects up to the number of fragments. The n-body &quot;</span>
    <span class="c1"># TODO         &quot;levels are effectively sorted in the outer list, and any &#39;supersystem&#39; element is at the end.&quot;)</span>
    <span class="c1"># json_schema_extra={</span>
    <span class="c1">#    &quot;shape&quot;: [&quot;nmc&quot;, &quot;&lt;varies&gt;&quot;],</span>
    <span class="c1"># },</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbodies_per_mc_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;supersystem&quot;</span><span class="p">]]]]:</span>
        <span class="c1"># print(f&quot;hit nbodies_per_mc_level&quot;, end=&quot;&quot;)</span>

        <span class="c1"># Organize nbody calculations into modelchem levels</span>
        <span class="c1"># * expand keys of `levels` into full lists of nbodies covered. save to plan, resetting max_nbody accordingly</span>
        <span class="c1"># * below, process values of `levels`, which are modelchem strings, into kwargs specs</span>
        <span class="n">nbodies_per_mc_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_body</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">:</span>
            <span class="n">nbodies</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="s2">&quot;supersystem&quot;</span><span class="p">:</span>
                <span class="n">nbodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nb</span> <span class="o">!=</span> <span class="p">(</span><span class="n">prev_body</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">prev_body</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">nbodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nbodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
            <span class="n">nbodies_per_mc_level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbodies</span><span class="p">)</span>
            <span class="n">prev_body</span> <span class="o">=</span> <span class="n">nb</span>  <span class="c1"># formerly buggy `+= 1`</span>

        <span class="c1"># print(f&quot; ... setting nbodies_per_mc_level={nbodies_per_mc_level}&quot;)</span>
        <span class="k">return</span> <span class="n">nbodies_per_mc_level</span>

    <span class="c1"># v2: @field_validator(&quot;max_nbody&quot;)</span>
<div class="viewcode-block" id="ManyBodyComputer.set_max_nbody">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.set_max_nbody">[docs]</a>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;max_nbody&quot;</span><span class="p">,</span> <span class="n">always</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="c1"># v2: def set_max_nbody(cls, v: Any, info: FieldValidationInfo) -&gt; int:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_max_nbody</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># print(f&quot;hit max_nbody validator with {v}&quot;, end=&quot;&quot;)</span>
        <span class="c1"># v2: levels_max_nbody = max(nb for nb in info.data[&quot;levels&quot;] if nb != &quot;supersystem&quot;)</span>
        <span class="c1"># v2: nfr = len(info.data[&quot;molecule&quot;].fragments)</span>
        <span class="n">levels_max_nbody</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nb</span> <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;levels&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">nb</span> <span class="o">!=</span> <span class="s2">&quot;supersystem&quot;</span><span class="p">)</span>
        <span class="n">nfr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span>
        <span class="c1"># print(f&quot; {levels_max_nbody=} {nfr=}&quot;, end=&quot;&quot;)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;levels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;levels&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot have duplicate model chemistries in levels.&quot;</span><span class="p">)</span>

        <span class="c1"># ALT if v == -1:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">levels_max_nbody</span>
        <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">nfr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_nbody=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> should be between 1 and </span><span class="si">{</span><span class="n">nfr</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">levels_max_nbody</span><span class="p">:</span>
            <span class="c1"># raise ValueError(f&quot;levels={levels_max_nbody} contradicts user max_nbody={v}.&quot;)</span>
            <span class="c1"># TODO reconsider logic. move this from levels to here?</span>
            <span class="c1"># v2: info.data[&quot;levels&quot;] = {v: &quot;(auto)&quot;}</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;levels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="s2">&quot;(auto)&quot;</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># TODO once was           return min(v, nfragments)</span>

        <span class="c1"># print(f&quot; ... setting max_nbody={v}&quot;)</span>
        <span class="k">return</span> <span class="n">v</span></div>


    <span class="c1">#       levels          max_nbody           F-levels        F-max_nbody     result</span>
    <span class="c1">#</span>
    <span class="c1">#       {stuff}         None                {stuff}         set from stuff  all consistent; max_nbody from levels</span>
    <span class="c1">#       None            int                 {int: mtd}      int             all consistent; levels from max_nbody</span>
    <span class="c1">#       None            None                {nfr: mtd}      nfr             all consistent; any order</span>
    <span class="c1">#       {stuff}         int                 {stuff}         int             need to check consistency</span>

    <span class="c1"># TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos&#39;n/label indexing coincides</span>

    <span class="c1"># v2: @field_validator(&quot;supersystem_ie_only&quot;)</span>
<div class="viewcode-block" id="ManyBodyComputer.set_supersystem_ie_only">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.set_supersystem_ie_only">[docs]</a>
    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;supersystem_ie_only&quot;</span><span class="p">,</span> <span class="n">always</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="c1"># v2: def set_supersystem_ie_only(cls, v: Optional[bool], info: FieldValidationInfo) -&gt; bool:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_supersystem_ie_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># print(f&quot;hit supersystem_ie_only validator with {v}&quot;, end=&quot;&quot;)</span>
        <span class="n">sio</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1"># v2: _nfr = len(info.data[&quot;molecule&quot;].fragments)</span>
        <span class="n">_nfr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span>

        <span class="c1"># v2: _max_nbody = info.data[&quot;max_nbody&quot;]</span>
        <span class="c1"># get(..., None) b/c in v1, all fields processed even if max_nbody previously failed</span>
        <span class="n">_max_nbody</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_nbody&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sio</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">_max_nbody</span> <span class="o">!=</span> <span class="n">_nfr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot skip intermediate n-body jobs when max_nbody=</span><span class="si">{</span><span class="n">_max_nbody</span><span class="si">}</span><span class="s2"> != nfragments=</span><span class="si">{</span><span class="n">_nfr</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sio</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;vmfc&quot;</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;bsse_type&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot skip intermediate n-body jobs when VMFC in bsse_type=</span><span class="si">{</span><span class="n">values</span><span class="p">[</span><span class="s1">&#39;bsse_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">. Use CP instead.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># print(f&quot; ... setting {sio=}&quot;)</span>
        <span class="k">return</span> <span class="n">sio</span></div>


<div class="viewcode-block" id="ManyBodyComputer.from_manybodyinput">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.from_manybodyinput">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_manybodyinput</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_model</span><span class="p">:</span> <span class="n">ManyBodyInput</span><span class="p">,</span> <span class="n">build_tasks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>

        <span class="n">computer_model</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">molecule</span><span class="o">=</span><span class="n">input_model</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="n">input_model</span><span class="o">.</span><span class="n">specification</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
            <span class="c1"># v2: **input_model.specification.keywords.model_dump(exclude_unset=True),</span>
            <span class="o">**</span><span class="n">input_model</span><span class="o">.</span><span class="n">specification</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">exclude_unset</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">input_data</span><span class="o">=</span><span class="n">input_model</span><span class="p">,</span>  <span class="c1"># storage, to reconstitute ManyBodyResult</span>
        <span class="p">)</span>
        <span class="n">nb_per_mc</span> <span class="o">=</span> <span class="n">computer_model</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span>

        <span class="c1"># print(&quot;\n&lt;&lt;&lt;  (ZZ 1) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben  &gt;&gt;&gt;&quot;)</span>
        <span class="c1"># v2: pprint.pprint(computer_model.model_dump(), width=200)</span>
        <span class="c1"># pprint.pprint(computer_model.dict(), width=200)</span>
        <span class="c1"># print(f&quot;nbodies_per_mc_level={nb_per_mc}&quot;)</span>

        <span class="n">comp_levels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">mc_level_idx</span><span class="p">,</span> <span class="n">mtd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">computer_model</span><span class="o">.</span><span class="n">levels</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">lvl1</span> <span class="ow">in</span> <span class="n">nb_per_mc</span><span class="p">[</span><span class="n">mc_level_idx</span><span class="p">]:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;supersystem&quot;</span> <span class="k">if</span> <span class="n">lvl1</span> <span class="o">==</span> <span class="s2">&quot;supersystem&quot;</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">lvl1</span><span class="p">)</span>
                <span class="n">comp_levels</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtd</span>

        <span class="n">specifications</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">mtd</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">computer_model</span><span class="o">.</span><span class="n">input_data</span><span class="o">.</span><span class="n">specification</span><span class="o">.</span><span class="n">specification</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
            <span class="n">specifications</span><span class="p">[</span><span class="n">mtd</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">specifications</span><span class="p">[</span><span class="n">mtd</span><span class="p">][</span><span class="s2">&quot;program&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;program&quot;</span><span class="p">)</span>
            <span class="n">specifications</span><span class="p">[</span><span class="n">mtd</span><span class="p">][</span><span class="s2">&quot;specification&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="n">specifications</span><span class="p">[</span><span class="n">mtd</span><span class="p">][</span><span class="s2">&quot;specification&quot;</span><span class="p">][</span>
                <span class="s2">&quot;driver&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">computer_model</span><span class="o">.</span><span class="n">driver</span>  <span class="c1"># overrides atomic driver with mb driver</span>
            <span class="n">specifications</span><span class="p">[</span><span class="n">mtd</span><span class="p">][</span><span class="s2">&quot;specification&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;schema_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">computer_model</span><span class="o">.</span><span class="n">qcmb_core</span> <span class="o">=</span> <span class="n">ManyBodyCore</span><span class="p">(</span>
            <span class="n">computer_model</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
            <span class="n">computer_model</span><span class="o">.</span><span class="n">bsse_type</span><span class="p">,</span>
            <span class="n">comp_levels</span><span class="p">,</span>
            <span class="n">return_total_data</span><span class="o">=</span><span class="n">computer_model</span><span class="o">.</span><span class="n">return_total_data</span><span class="p">,</span>
            <span class="n">supersystem_ie_only</span><span class="o">=</span><span class="n">computer_model</span><span class="o">.</span><span class="n">supersystem_ie_only</span><span class="p">,</span>
            <span class="n">embedding_charges</span><span class="o">=</span><span class="n">computer_model</span><span class="o">.</span><span class="n">embedding_charges</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># check that core and computer storage are consistent in mc ordering and grouping and nbody levels</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">computer_model</span><span class="o">.</span><span class="n">qcmb_core</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="n">computer_model</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;CORE </span><span class="si">{</span><span class="n">computer_model</span><span class="o">.</span><span class="n">qcmb_core</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="si">}</span><span class="s2"> != COMPUTER </span><span class="si">{</span><span class="n">computer_model</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">computer_model</span><span class="o">.</span><span class="n">qcmb_core</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">computer_model</span><span class="o">.</span><span class="n">levels</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;CORE </span><span class="si">{</span><span class="n">computer_model</span><span class="o">.</span><span class="n">qcmb_core</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> != COMPUTER </span><span class="si">{</span><span class="n">computer_model</span><span class="o">.</span><span class="n">levels</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">build_tasks</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">computer_model</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">qcengine</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">qcng</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="s2">&quot;Python module qcengine not found. Solve by installing it: &quot;</span>
                <span class="s2">&quot;`conda install qcengine -c conda-forge` or `pip install qcengine`&quot;</span>
            <span class="p">)</span>

        <span class="n">component_properties</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">component_results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">chem</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">imol</span> <span class="ow">in</span> <span class="n">computer_model</span><span class="o">.</span><span class="n">qcmb_core</span><span class="o">.</span><span class="n">iterate_molecules</span><span class="p">():</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">AtomicInput</span><span class="p">(</span><span class="n">molecule</span><span class="o">=</span><span class="n">imol</span><span class="p">,</span> <span class="o">**</span><span class="n">specifications</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="s2">&quot;specification&quot;</span><span class="p">])</span>
            <span class="c1"># inp = AtomicInput(molecule=imol, **specifications[chem][&quot;specification&quot;], extras={&quot;psiapi&quot;: True})  # faster for p4</span>

            <span class="k">if</span> <span class="n">imol</span><span class="o">.</span><span class="n">extras</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;embedding_charges&quot;</span><span class="p">):</span>  <span class="c1"># or test on self.embedding_charges ?</span>
                <span class="k">if</span> <span class="n">specifications</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="s2">&quot;program&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;psi4&quot;</span><span class="p">:</span>
                    <span class="n">charges</span> <span class="o">=</span> <span class="n">imol</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s2">&quot;embedding_charges&quot;</span><span class="p">]</span>
                    <span class="n">fkw</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;function_kwargs&quot;</span><span class="p">,</span> <span class="p">{})</span>
                    <span class="n">fkw</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;external_potentials&quot;</span><span class="p">:</span> <span class="n">charges</span><span class="p">})</span>
                    <span class="n">inp</span><span class="o">.</span><span class="n">keywords</span><span class="p">[</span><span class="s2">&quot;function_kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fkw</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to handle external charges in </span><span class="si">{</span><span class="n">specifications</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="s1">&#39;program&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">bas</span> <span class="o">=</span> <span class="n">delabeler</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">qcng</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">specifications</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="s2">&quot;program&quot;</span><span class="p">])</span>
            <span class="n">component_results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
                <span class="c1"># print(result.error.error_message)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Calculation did not succeed! Error:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

            <span class="c1"># pull out stuff</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;energy&quot;</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;hessian&quot;</span><span class="p">}</span>

            <span class="n">component_properties</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">properties</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;return_</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">properties</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;return_</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="c1"># print(f&quot;  {label} {p}: {v}&quot;)</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">component_properties</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># print(&quot;\n&lt;&lt;&lt;  (ZZ 2) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben component_properties  &gt;&gt;&gt;&quot;)</span>
        <span class="c1"># with np.printoptions(precision=6, suppress=True):</span>
        <span class="c1">#     pprint.pprint(component_properties, width=200)</span>

        <span class="n">analyze_back</span> <span class="o">=</span> <span class="n">computer_model</span><span class="o">.</span><span class="n">qcmb_core</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">component_properties</span><span class="p">)</span>
        <span class="n">analyze_back</span><span class="p">[</span><span class="s2">&quot;nbody_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_properties</span><span class="p">)</span>
        <span class="c1"># print(&quot;\n&lt;&lt;&lt;  (ZZ 3) QCEngine harness ManyBodyComputerQCNG.from_qcschema_ben analyze_back  &gt;&gt;&gt;&quot;)</span>
        <span class="c1"># pprint.pprint(analyze_back, width=200)</span>

        <span class="k">return</span> <span class="n">computer_model</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="n">external_results</span><span class="o">=</span><span class="n">analyze_back</span><span class="p">,</span> <span class="n">component_results</span><span class="o">=</span><span class="n">component_results</span><span class="p">)</span></div>


<div class="viewcode-block" id="ManyBodyComputer.plan">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.plan">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># uncalled function</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">plan</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span></div>


<div class="viewcode-block" id="ManyBodyComputer.compute">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.client.PortalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run quantum chemistry.</span>

<span class="sd">        NOTE: client logic removed (compared to psi4.driver.ManyBodyComputer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">t</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span></div>


<div class="viewcode-block" id="ManyBodyComputer.get_results">
<a class="viewcode-back" href="../../api/qcmanybody.computer.ManyBodyComputer.html#qcmanybody.ManyBodyComputer.get_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_results</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">external_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">component_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.client.PortalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ManyBodyResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return results as ManyBody-flavored QCSchema.&quot;&quot;&quot;</span>

        <span class="n">ret_energy</span> <span class="o">=</span> <span class="n">external_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ret_energy&quot;</span><span class="p">)</span>
        <span class="n">ret_ptype</span> <span class="o">=</span> <span class="n">ret_energy</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span> <span class="k">else</span> <span class="n">external_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ret_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ret_gradient</span> <span class="o">=</span> <span class="n">external_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ret_gradient&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">nbody_number</span> <span class="o">=</span> <span class="n">external_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nbody_number&quot;</span><span class="p">)</span>
        <span class="n">component_properties</span> <span class="o">=</span> <span class="n">external_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;component_properties&quot;</span><span class="p">)</span>
        <span class="n">stdout</span> <span class="o">=</span> <span class="n">external_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;stdout&quot;</span><span class="p">)</span>

        <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;calcinfo_nmc&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="p">),</span>
            <span class="s2">&quot;calcinfo_nfr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfragments</span><span class="p">,</span>  <span class="c1"># or len(self.molecule.fragments)</span>
            <span class="s2">&quot;calcinfo_natom&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">symbols</span><span class="p">),</span>
            <span class="s2">&quot;calcinfo_nmbe&quot;</span><span class="p">:</span> <span class="n">nbody_number</span><span class="p">,</span>
            <span class="s2">&quot;nuclear_repulsion_energy&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
            <span class="s2">&quot;return_energy&quot;</span><span class="p">:</span> <span class="n">ret_energy</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_gradient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_ptype</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;hessian&quot;</span><span class="p">:</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_gradient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_gradient</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_hessian&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_ptype</span>

        <span class="c1">#        output_data = {</span>
        <span class="c1">#            &quot;schema_version&quot;: 1,</span>
        <span class="c1">#            &quot;molecule&quot;: gamessmol,  # overwrites with outfile Cartesians in case fix_*=F</span>
        <span class="c1">#            &quot;extras&quot;: {**input_model.extras},</span>
        <span class="c1">#            &quot;native_files&quot;: {k: v for k, v in outfiles.items() if v is not None},</span>
        <span class="c1">#            &quot;properties&quot;: atprop,</span>

        <span class="c1">#####</span>
        <span class="c1">#        nbody_model = self.get_results(client=client)</span>
        <span class="c1">#        ret = nbody_model.return_result</span>
        <span class="c1">#</span>
        <span class="c1">#        wfn = core.Wavefunction.build(self.molecule, &quot;def2-svp&quot;, quiet=True)</span>
        <span class="c1">#</span>
        <span class="c1">#        # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., &quot;2&quot;)</span>

        <span class="c1"># print(&quot;QCVARS PRESCREEN&quot;)</span>
        <span class="c1"># pp.pprint(qcvars)</span>

        <span class="c1"># v2: component_results = self.model_dump()[&#39;task_list&#39;]  # TODO when/where include the indiv outputs</span>
        <span class="c1"># ?component_results = self.dict()[&#39;task_list&#39;]  # TODO when/where include the indiv outputs</span>
        <span class="c1">#        for k, val in component_results.items():</span>
        <span class="c1">#            val[&#39;molecule&#39;] = val[&#39;molecule&#39;].to_schema(dtype=2)</span>

        <span class="n">nbody_model</span> <span class="o">=</span> <span class="n">ManyBodyResult</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="s2">&quot;input_data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_data</span><span class="p">,</span>
                <span class="c1">#&#39;molecule&#39;: self.molecule,</span>
                <span class="c1"># v2: &#39;properties&#39;: {**atprop.model_dump(), **properties},</span>
                <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span><span class="o">**</span><span class="n">external_results</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">],</span> <span class="o">**</span><span class="n">properties</span><span class="p">},</span>
                <span class="s2">&quot;component_properties&quot;</span><span class="p">:</span> <span class="n">component_properties</span><span class="p">,</span>
                <span class="s2">&quot;component_results&quot;</span><span class="p">:</span> <span class="n">component_results</span><span class="p">,</span>
                <span class="s2">&quot;provenance&quot;</span><span class="p">:</span> <span class="n">provenance_stamp</span><span class="p">(</span><span class="vm">__name__</span><span class="p">),</span>
                <span class="s2">&quot;return_result&quot;</span><span class="p">:</span> <span class="n">ret_ptype</span><span class="p">,</span>
                <span class="s2">&quot;stdout&quot;</span><span class="p">:</span> <span class="n">stdout</span><span class="p">,</span>
                <span class="s2">&quot;success&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1">#        logger.debug(&#39;\nNBODY QCSchema:\n&#39; + pp.pformat(nbody_model.model_dump()))</span>

        <span class="k">return</span> <span class="n">nbody_model</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024-2026, QCManyBody Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>